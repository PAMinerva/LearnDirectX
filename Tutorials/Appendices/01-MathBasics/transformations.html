
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Transformations &#8212; Learn DirectX</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=bd9e20870c6007c4c509"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=afe5de03"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Tutorials/Appendices/01-MathBasics/transformations';</script>
    <link rel="canonical" href="https://github.com/PAMinerva/LearnDirectX/Tutorials/Appendices/01-MathBasics/transformations.html" />
    <link rel="icon" href="../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="prev" title="Matrices" href="matrices.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <header>


  <div class="bd-header-announcement container-fluid bd-header-announcement">
    <div class="bd-header-announcement__content">🚧 This documentation is a work in progress! 🚧</div>
  </div>

  
    <div class="bd-header navbar navbar-expand-lg bd-navbar">
    </div>
  
  </header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../presentation.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Learn DirectX - Home"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Learn DirectX - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../presentation.html">
                    Welcome to Learn DirectX
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../00-Intro/intro-and-prerequisites.html">Introduction and Prerequisites</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Hello DirectX</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../01-HelloWorld/hello-world.html">Hello World</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-window.html">Hello Window</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-triangle.html">Hello Triangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-bundles.html">Hello Bundles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-cbs.html">Hello Constant Buffers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-texture.html">Hello Texture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-frame-buffering.html">Hello Frame Buffering</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="math-basics.html">Math Basics</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="vectors.html">Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html">Matrices</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Transformations</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/PAMinerva/LearnDirectX" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/PAMinerva/LearnDirectX/issues/new?title=Issue%20on%20page%20%2FTutorials/Appendices/01-MathBasics/transformations.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/Tutorials/Appendices/01-MathBasics/transformations.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Transformations</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-transformations">Linear transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scaling">Scaling</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation">Rotation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#affine-transformations">Affine transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translation">Translation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#homogeneous-coordinates">Homogeneous coordinates</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#composition-of-transformations">Composition of transformations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#transformation-in-directx">Transformation in DirectX</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="transformations">
<h1>Transformations<a class="headerlink" href="#transformations" title="Link to this heading">#</a></h1>
<p>In graphics applications, it is common to apply transformations such as scaling, rotation, and translation to objects before displaying them on the screen. For example, let’s consider a scenario where you want to move an object to a different position in the scene. In order to achieve this, you need to move all the vertices of the object by applying a transformation on them. Matrices are mathematical entities that represent transformations. This means that if we treat vertex positions as vectors in a 3D space, we can multiply them by a matrix to change their position, orientation and magnitude in the scene. In the example given, we would perform a matrix multiplication between each vertex position <span class="math notranslate nohighlight">\(\mathbf{v}=(x,y,z)\)</span> stored in the vertex buffer and a translation matrix <span class="math notranslate nohighlight">\(T\)</span> in order to change its coordinates.</p>
<div class="math notranslate nohighlight">
\[T(\mathbf{v})=(x\textrm', y\textrm', z\textrm')=\mathbf{w}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> represents the new position of the vertex <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> after the transformation <span class="math notranslate nohighlight">\(T\)</span>. <br>
Now, it’s interesting how we can visualize it in two different ways. Obviously, we can move (translate) <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> until its coordinate match those of <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>. Alternatively, we can translate the entire frame to achieve the same result. In <a class="reference internal" href="vectors.html"><span class="std std-doc">Vectors</span></a>, we established that points (and therefore positions) are vectors bound to the origin of a frame, which can be described by the coordinates of the corresponding arrowheads. In the illustration below, on the left side, we translate the arrowhead of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> by changing its coordinates, resulting in the vector\position <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>. On the right side of the illustration, we apply the same translation to the origin of the frame. As you can observe, the coordinates of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> with respect to the transformed frame A remain the same because the vector shares the same fate (transformation) as its frame of reference. However, now the original frame B “see” <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> as being applied to the origin of frame A. Consequently, the coordinates of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> with respect to the original frame B are the same as those of <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>. Thus, we can consider the transformed frame A as the starting frame, while the original frame B as the new frame of reference.</p>
<figure class="align-default">
<img alt="../../../_images/transformation.png" src="../../../_images/transformation.png" />
</figure>
<p>The same concept applies when rotating or scaling a vertex position. As we will explore in this tutorial, vector transformations and changes of coordinate systems are mathematically equivalent. In other words, transforming an object is equivalent to transforming its frame of reference, and vice versa.</p>
<br>
<section id="linear-transformations">
<h2>Linear transformations<a class="headerlink" href="#linear-transformations" title="Link to this heading">#</a></h2>
<p>A transformation <span class="math notranslate nohighlight">\(L\)</span> is linear if it satisfies the following two conditions for any two vectors <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, and any scalar <span class="math notranslate nohighlight">\(k\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
L(\mathbf{u}+\mathbf{v})&amp;=L(\mathbf{u})+L(\mathbf{v}) \\
\\
L(k\mathbf{v})&amp;=kL(\mathbf{v})
\end{align*}
\end{split}\]</div>
<p>In <a class="reference internal" href="vectors.html"><span class="std std-doc">Vectors</span></a>, it was demonstrated that a generic bound vector <span class="math notranslate nohighlight">\(\mathbf{v}=(x,y,z)\)</span> can be expressed as a linear combination as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}=x\mathbf{i}+y\mathbf{j}+z\mathbf{k}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> are the basis vectors that describe a frame, and <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> are the coefficients that determine the magnitude and direction of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> along each basis vector. Therefore, following the linearity conditions illustrated above, we can express the transformation of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> as:</p>
<div class="math notranslate nohighlight">
\[L(\mathbf{v})=L(x\mathbf{i}+y\mathbf{j}+z\mathbf{k})=xL(\mathbf{i})+yL(\mathbf{j})+zL(\mathbf{k})=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}=\mathbf{w}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\mathbf{f}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{g}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> represent the transformed standard basis vectors. These vectors correspond to the standard basis vectors of the transformed frame. It’s important to note that the coordinates of <span class="math notranslate nohighlight">\(\mathbf{f}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{g}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> are expressed with respect to the original frame. For example, in the illustration below, a linear transformation <span class="math notranslate nohighlight">\(L\)</span> is applied to the standard basis vectors <span class="math notranslate nohighlight">\(\mathbf{i}=(1,0)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{j}=(0,1)\)</span> of a frame B. This create a new frame A (since the transformed standard basis vector will represent the standard basis vector in a new coordinate system). However, observe that, in the transformed frame A, the coordinates of the transformed <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> remain <span class="math notranslate nohighlight">\((1,0)\)</span> ─ the same applies to <span class="math notranslate nohighlight">\(L(\mathbf{i})\)</span> in frame A. On the other hand, we have <span class="math notranslate nohighlight">\(L(\mathbf{i})=\mathbf{f}=(x',y')\)</span> in frame B, which represents the original frame ─ again, the same applies to <span class="math notranslate nohighlight">\(L(\mathbf{i})\)</span> in frame B. Therefore, we can consider the transformed frame A as our initial starting point, where <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> were <span class="math notranslate nohighlight">\((1,0)\)</span> and <span class="math notranslate nohighlight">\((0,1)\)</span>, while the frame B represents the final result after applying the transformation <span class="math notranslate nohighlight">\(L\)</span> to both <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{j}\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/linear-transformation.png" src="../../../_images/linear-transformation.png" />
</figure>
<p>Then, we can conclude that applying a linear transformation to a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is equivalent to applying the same transformation to the initial frame, represented by its standard basis vectors. This is crucial because it means that transforming a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> with a linear transformation can be achieved by transforming the standard basis vectors of the frame in which the vector is defined.</p>
<p>Furthermore, it has been shown that the coordinates of the transformed vector <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> can be obtained as a linear combination of the transformed basis vectors, with the components of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> used as coefficients. From <a class="reference internal" href="matrices.html"><span class="std std-doc">Matrices</span></a>, we know that a linear combination can be expressed as the product of a row vector and a column vector, which is related to the concept of dot product. Therefore, we can express the transformation as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\mathbf{w}=L(\mathbf{v})&amp;=L(x\mathbf{i}+y\mathbf{j}+z\mathbf{k})=xL(\mathbf{i})+yL(\mathbf{j})+zL(\mathbf{k})=x\mathbf{f}+y\mathbf{g}+z\mathbf{h} \\
\\
&amp;=\mathbf{v}\cdot\mathbf{m}=\left\lbrack\matrix{x&amp;y&amp;z}\right\rbrack\left\lbrack\matrix{\gets&amp;\mathbf{f}&amp;\rightarrow\cr \gets&amp;\mathbf{g}&amp;\rightarrow\cr \gets&amp;\mathbf{h}&amp;\rightarrow}\right\rbrack \\
\\
&amp;=\mathbf{vM}=\left\lbrack\matrix{x&amp;y&amp;z}\right\rbrack\left\lbrack\matrix{M_{00}&amp;M_{01}&amp;M_{02}\cr M_{10}&amp;M_{11}&amp;M_{12}\cr M_{20}&amp;M_{21}&amp;M_{22}}\right\rbrack \\
\\
&amp;=\left\lbrack\matrix{\mathbf{v}\cdot\mathbf{M}_{\ast 0}&amp;\mathbf{v}\cdot\mathbf{M}_{\ast 1}&amp;\mathbf{v}\cdot\mathbf{M}_{\ast 2}}\right\rbrack
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{v}=(x, y, z)\)</span>, <span class="math notranslate nohighlight">\(\mathbf{m}=(\mathbf{f},\mathbf{g},\mathbf{h})\)</span>, <span class="math notranslate nohighlight">\(\mathbf{f}=\left\lbrack\matrix{M_{00}&amp;M_{01}&amp;M_{02}}\right\rbrack\)</span>, <span class="math notranslate nohighlight">\(\mathbf{g}=\left\lbrack\matrix{M_{10}&amp;M_{11}&amp;M_{12}}\right\rbrack\)</span> and <span class="math notranslate nohighlight">\(\mathbf{h}=\left\lbrack\matrix{M_{20}&amp;M_{21}&amp;M_{22}}\right\rbrack\)</span>.</p>
<p>That’s exactly what we have seen in <a class="reference internal" href="matrices.html"><span class="std std-doc">Matrices</span></a>. Indeed, if we perform the multiplication between the row vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and the matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\mathbf{vM}&amp;=\left\lbrack\matrix{\mathbf{v}\cdot\mathbf{M}_{\ast0}&amp;\mathbf{v}\cdot\mathbf{M}_{\ast1}&amp;\mathbf{v}\cdot\mathbf{M}_{\ast2}}\right\rbrack \\
\\
&amp;=\left\lbrack\matrix{xM_{00}+yM_{10}+zM_{20}&amp;xM_{01}+yM_{11}+zM_{21}&amp;xM_{02}+yM_{12}+zM_{22}}\right\rbrack \\
\\
&amp;=\left\lbrack\matrix{xM_{00}&amp;xM_{01}&amp;xM_{02}}\right\rbrack+\left\lbrack\matrix{yM_{10}&amp;yM_{11}&amp;yM_{12}}\right\rbrack+\left\lbrack\matrix{zM_{20}&amp;zM_{21}&amp;zM_{22}}\right\rbrack \\
\\
&amp;=x\mathbf{M}_{0\ast}+y\mathbf{M}_{1\ast}+z\mathbf{M}_{2\ast}=x\mathbf{f}+y\mathbf{g}+z\mathbf{h} =\mathbf{w}
\tag{1}
\label{eq:ATransforms1}
\end{align*}
\end{split}\]</div>
<p>We just found that to transform a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> we need to multiply it by a matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> whose rows are the transformed standard basis vectors. In other words, we can express this relationship as:</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}=\mathbf{vM}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the matrix that transforms a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> into another vector <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>.<br>
However, we can also interpret <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> as the matrix to go from a frame A (the starting one) to a frame B (the new one), which allows a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> bound to the origin of frame A to be expressed with respect to frame B. We can demonstrate this intricated conclusion with a simple illustration.</p>
<figure class="align-default">
<img alt="../../../_images/linear-transformation2.png" src="../../../_images/linear-transformation2.png" />
</figure>
<p>On the left side of the image above, we have a vector <span class="math notranslate nohighlight">\(\mathbf{p}_A=(3,2)\)</span> applied to the origin of a frame A. Recall that a vector can be expressed as a linear combination of the standard basis vectors, using its components as coefficients. Thus, in frame A, we have:</p>
<div class="math notranslate nohighlight">
\[\mathbf{p}_A=3\mathbf{i}+2\mathbf{j}\]</div>
<p>This representation corresponds to the diagonal of the parallelogram formed by scaling the vectors <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> using the components of <span class="math notranslate nohighlight">\(\mathbf{p}_A\)</span> as coefficients.</p>
<p>Now, imagine scaling frame A twice along both the x-axis and y-axis, followed by a rotation around the origin. This transformation results in the vector <span class="math notranslate nohighlight">\(\mathbf{p}_A\)</span> being doubled in size and rotated with respect to the original frame, which can therefore be considered as a new frame B because in the transformed one (A) the coordinates of <span class="math notranslate nohighlight">\(\mathbf{p}_A\)</span> are still <span class="math notranslate nohighlight">\((3,2)\)</span>. As stated earlier, <span class="math notranslate nohighlight">\(L(\mathbf{i})\)</span> and <span class="math notranslate nohighlight">\(L(\mathbf{j})\)</span> are expressed in coordinates with respect to the original frame B. Now, our goal is to demonstrate that using these transformed basis vectors as rows of a matrix, we can compute the coordinates of <span class="math notranslate nohighlight">\(\mathbf{p}_A\)</span> with respect to frame B. In other words, we aim to show that this matrix enables us to transition from frame A to frame B. As depicted on the right side of the illustration above, we have that</p>
<div class="math notranslate nohighlight">
\[\mathbf{p}_B=3L(\mathbf{i})+2L(\mathbf{j})\]</div>
<p>That is, <span class="math notranslate nohighlight">\(\mathbf{p}_A\)</span> with respect to the frame B is the diagonal of the transformed standard basis vectors, scaled using the components of <span class="math notranslate nohighlight">\(\mathbf{p}_A\)</span>. In other words, the coordinates of <span class="math notranslate nohighlight">\(\mathbf{p}_A\)</span> with respect to frame B can be expressed as a linear combination of the transformed basis vectors, using the components of <span class="math notranslate nohighlight">\(\mathbf{p}_A\)</span> as coefficients. This is exactly what we formally proved in equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms1}\)</span>, where we used the transformed basis vectors as rows of the matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>.</p>
<p>Thus, we have just demonstrated that <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the matrix to express the coordinates of a vector in a frame A with respect to a frame B. That is, we have shown that <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> allows to go from frame A (the original one) to frame B (the transformed one). At this point, it should come as no surprise that the inverse matrix <span class="math notranslate nohighlight">\(\mathbf{M}^{-1}\)</span> represents the transformation to go from frame B back to frame A.</p>
<section id="scaling">
<span id="transforms-scaling-label"></span><h3>Scaling<a class="headerlink" href="#scaling" title="Link to this heading">#</a></h3>
<p>In a 3D Cartesian coordinate system, vectors can be scaled independently in three directions by scaling their respective components. That is, given a scaling <span class="math notranslate nohighlight">\(S\)</span> and a vector <span class="math notranslate nohighlight">\(\mathbf{v}=(x,y,z)\)</span> we have</p>
<div class="math notranslate nohighlight">
\[S(\mathbf{v})=(s_xx, s_yy, s_zz)\]</div>
<p>Here, <span class="math notranslate nohighlight">\(s_x\)</span>, <span class="math notranslate nohighlight">\(s_y\)</span>, and <span class="math notranslate nohighlight">\(s_z\)</span> represent the scaling factors associated with the x, y, and z directions, respectively. This allows us to stretch or shrink vectors in each direction independently, altering their overall size and proportions.</p>
<p>The scaling is uniform if the scaling factors are equal <span class="math notranslate nohighlight">\((s_x=s_y=s_z)\)</span>, otherwise it’s non-uniform. We can formally prove the scaling is a linear transformation by showing that it satisfies the two conditions of linearity.</p>
<div class="dropdown admonition">
<p class="admonition-title">Proof</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
S(\mathbf{u}+\mathbf{v})&amp;=\big( s_x(u_x+v_x),\ s_y(u_y+v_y),\ s_z(u_z+v_z) \big) \\ \\
&amp;=(s_xu_x+s_xv_x,\ s_yu_y+s_yv_y,\ s_zu_z+s_zv_z) \\ \\
&amp;=(s_xu_x,\ s_yu_y,\ s_zu_z)+(s_xv_x,\ s_yv_y,\ s_zv_z) \\ \\
&amp;=S(\mathbf{u})+S(\mathbf{v}) \\ \\
\\
S(k\mathbf{v})&amp;=(s_xkv_x,\ s_ykv_y,\ s_zkv_z) \\ \\
&amp;=k(s_xv_x,\ s_yv_y,\ s_zv_z) \\ \\
&amp;=kS(\mathbf{v})
\end{flalign}
\end{split}\]</div>
</div>
<p>We know that a linear transformation can be associated with a matrix whose rows are the transformed standard basis vectors. In 3D Cartesian coordinate systems, we have that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
S(\mathbf{i})&amp;=(s_x1,\ s_y0,\ s_z0)=(s_x,0,0) \\ \\
S(\mathbf{j})&amp;=(s_x0,\ s_y1,\ s_z0)=(0,s_y,0) \\ \\
S(\mathbf{k})&amp;=(s_x0,\ s_y0,\ s_z1)=(0,0,s_z)
\end{align*}
\end{split}\]</div>
<p>Then, the matrix <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> associated with a scaling is</p>
<div class="math notranslate nohighlight">
\[\mathbf{S}=\left\lbrack\matrix{s_x&amp;0&amp;0\cr 0&amp;s_y&amp;0\cr 0&amp;0&amp;s_z}\right\rbrack\]</div>
<p>This matrix is associated with the scaling operation. Consequently, we can apply scaling to any 3D vector by multiplying it with the scaling matrix <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>. If the intention is to restore the vector to its original size, we can accomplish this by multiplying the scaled vector by the inverse of the scaling matrix, denoted as <span class="math notranslate nohighlight">\(\mathbf{S}^{-1}\)</span>.</p>
<div class="math notranslate nohighlight">
\[S^{-1}=\left\lbrack\matrix{1/s_x&amp;0&amp;0\cr 0&amp;1/s_y&amp;0\cr 0&amp;0&amp;1/s_z}\right\rbrack\]</div>
<div class="proof example admonition" id="example-0">
<p class="admonition-title"><span class="caption-number">Example 2 </span></p>
<section class="example-content" id="proof-content">
<p>Given a minimum point <span class="math notranslate nohighlight">\(\mathbf{p}=(-2,0,-2)\)</span> and a maximum point <span class="math notranslate nohighlight">\(\mathbf{q}=(2,0,2)\)</span> defining a square, if you want to scale it by a factor of <span class="math notranslate nohighlight">\(2\)</span> along the x-axis, <span class="math notranslate nohighlight">\(0.5\)</span> along the z-axis, and leave the y-coordinate unchanged, you can use the corresponding scaling matrix:</p>
<div class="math notranslate nohighlight">
\[\mathbf{S}=\left\lbrack\matrix{2&amp;0&amp;0\cr 0&amp;1&amp;0\cr 0&amp;0&amp;0.5}\right\rbrack\]</div>
<p>To scale the square, we need to multiply both <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> by <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\left\lbrack\matrix{-2&amp;0&amp;-2}\right\rbrack\left\lbrack\matrix{2&amp;0&amp;0\cr 0&amp;1&amp;0\cr 0&amp;0&amp;0.5}\right\rbrack&amp;=\left\lbrack\matrix{-4&amp;0&amp;-1}\right\rbrack \\ 
\\
\left\lbrack\matrix{2&amp;0&amp;2}\right\rbrack\left\lbrack\matrix{2&amp;0&amp;0\cr 0&amp;1&amp;0\cr 0&amp;0&amp;0.5}\right\rbrack&amp;=\left\lbrack\matrix{4&amp;0&amp;1}\right\rbrack
\end{align*}
\end{split}\]</div>
<p>The following illustration shows the result of these transformations</p>
<figure class="align-default">
<img alt="../../../_images/scaling.png" src="../../../_images/scaling.png" />
</figure>
</section>
</div></section>
<section id="rotation">
<h3>Rotation<a class="headerlink" href="#rotation" title="Link to this heading">#</a></h3>
<p>A rotation is a linear transformation, but a formal proof of this won’t be provided since it is simpler to observe, from the illustration below, that the rotation of the sum of two vectors (that is, the rotation of the diagonal of the parallelogram defined by the two vectors) is equivalent to the sum of rotations of the two vectors (that is, the diagonal of the rotated parallelogram). At the same time, rotating a uniformly scaled vector is equivalent to first rotating the vector and then applying the uniform scaling.</p>
<figure class="align-default">
<img alt="../../../_images/rotation-linear.png" src="../../../_images/rotation-linear.png" />
</figure>
<p>Finding the matrix associated with a rotation can be slightly more challenging compared to scaling. However, for the purpose of our discussion, we will consider <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v})\)</span> as a clockwise rotation of a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> around a unit vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> by an angle <span class="math notranslate nohighlight">\(\theta\)</span>. That is, you will see the vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> rotating clockwise when looking down the positive direction of the unit vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>, which determines the axis of rotation. Obviously, the result of <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v})\)</span> is the rotated version of the vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> passed as an argument.</p>
<p>If a counterclockwise rotation is desired, the angle <span class="math notranslate nohighlight">\(\theta\)</span> can simply be negated. Additionally, if <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> is not a unit vector, we can always normalize it, allowing us to extend our results to the more general case.</p>
<p>Now, let’s consider the left side of the illustration below.</p>
<figure class="align-default">
<img alt="../../../_images/rotation2.png" src="../../../_images/rotation2.png" />
</figure>
<p>From <a class="reference internal" href="vectors.html"><span class="std std-doc">Vectors</span></a>, we know that <span class="math notranslate nohighlight">\(\mathbf{n}\times\mathbf{v}\)</span> is orthogonal to the plane defined by <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. During the rotation, the vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> traces out an arc of a circle, which is also orthogonal to the plane defined by <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. Therefore, the vector <span class="math notranslate nohighlight">\(\mathbf{n}\times\mathbf{v}\)</span> and the circle drawn by <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> lie in the same plane.</p>
<p>Now, let’s consider the projection of the vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> onto <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>. It can be expressed as the difference between two vectors; this result can also be derived from <a class="reference internal" href="vectors.html#vectors-gram-schmidt-label"><span class="std std-ref">Gram-Schmidt Orthogonalization</span></a>.</p>
<div class="math notranslate nohighlight">
\[\text{proj}_\mathbf{n}(\mathbf{v})=\mathbf{v}-\mathbf{v}_\bot\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{v}_\bot\)</span> is the orthogonal component of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> with respect to <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>. Therefore, we have that</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}_\bot=\mathbf{v}-\text{proj}_\mathbf{n}(\mathbf{v})\]</div>
<p>The vector <span class="math notranslate nohighlight">\(\mathbf{v}_\bot\)</span> lies in the plane defined by <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> (since it’s the subtraction of these two vectors) and therefore it’s orthogonal to <span class="math notranslate nohighlight">\(\mathbf{n}\times\mathbf{v}\)</span>. <span class="math notranslate nohighlight">\(\ R_\mathbf{n}(\mathbf{v}_\bot)\)</span> is the orthogonal component of <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v})\)</span> with respect to <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>. Moreover, observe that</p>
<div class="math notranslate nohighlight">
\[\vert\mathbf{n}\times\mathbf{v}\vert=\vert\mathbf{n}\vert\vert\mathbf{v}\vert\sin a=\vert\mathbf{v}\vert\sin a =\vert\mathbf{v}_\bot\vert\]</div>
<p>That is, <span class="math notranslate nohighlight">\(\mathbf{n}\times\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}_\bot\)</span> have the same length, and are orthogonal to each other. So, they can define a 2D frame (just like the standard basis vectors <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{j}\)</span>) where we can compute the coordinates of <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v}_\bot)\)</span>, which can be considered as the rotation of the basis vector <span class="math notranslate nohighlight">\(\mathbf{v}_\bot\)</span> about <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>. This means that <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v}_\bot)\)</span> has the same length of both <span class="math notranslate nohighlight">\(\mathbf{n}\times\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}_\bot\)</span>. As you can see in the image above (on the right), the orthogonal projection of <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v}_\bot)\)</span> onto <span class="math notranslate nohighlight">\(\mathbf{v}_\bot\)</span> is</p>
<div class="math notranslate nohighlight">
\[\displaystyle\frac{(R_\mathbf{n}(\mathbf{v}_\bot)\cdot\mathbf{v}_\bot)}{\vert\mathbf{v}_\bot\vert^2}\mathbf{v}_\bot=\frac{\vert R_\mathbf{n}(\mathbf{v}_\bot)\vert\vert\mathbf{v}_\bot\vert\cos\theta}{\vert\mathbf{v}_\bot\vert^2}\mathbf{v}_\bot=\frac{\vert\mathbf{v}_\bot\vert\vert\mathbf{v}_\bot\vert\cos\theta}{\vert\mathbf{v}_\bot\vert^2}\mathbf{v}_\bot=\cos{\mathbf{\theta}}\ \mathbf{v}_\bot\]</div>
<p>In a similar way, the orthogonal projection of <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v} _\bot)\)</span> onto <span class="math notranslate nohighlight">\(\mathbf{n}\times\mathbf{v}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\displaystyle\frac{(R_\mathbf{n}(\mathbf{v}_\bot)\cdot\mathbf{n}\times\mathbf{v})}{\vert\mathbf{n}\times\mathbf{v}\vert^2}\mathbf{n}\times\mathbf{v}=\frac{\vert R_\mathbf{n}(\mathbf{v}_\bot)\vert\vert\mathbf{n}\times\mathbf{v}\vert\cos{(90°-\theta)}}{\vert\mathbf{n}\times\mathbf{v}\vert^2}\mathbf{n}\times\mathbf{v}=\frac{\vert\mathbf{n}\times\mathbf{v}\vert\vert\mathbf{n}\times\mathbf{v}\vert\sin\theta}{\vert\mathbf{n}\times\mathbf{v}\vert^2}\mathbf{n}\times\mathbf{v}=\sin\theta\ \mathbf{n}\times\mathbf{v}\]</div>
<p>Therefore, we have that</p>
<div class="math notranslate nohighlight">
\[R_\mathbf{n}(\mathbf{v}_\bot)=\cos\theta\ \mathbf{v}_\bot+\sin\theta\ (\mathbf{n}\times\mathbf{v})\]</div>
<p>Now, we can compute <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v})\)</span> as a sum of <span class="math notranslate nohighlight">\(\text{proj}_\mathbf{n}(\mathbf{v})\)</span> and <span class="math notranslate nohighlight">\(R_\mathbf{n}(\mathbf{v}_\bot)\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
R_{\mathbf{n}}(\mathbf{v})&amp;=\text{proj}_\mathbf{n}(\mathbf{v})+R_{\mathbf{n}}(\mathbf{v_\bot}) \\ 
\\
&amp;=(\mathbf{n}\cdot \mathbf{v})\mathbf{n}+\cos\theta\ \mathbf{v}_\bot+\sin\theta\ (\mathbf{n}\times\mathbf{v}) \\
\\
&amp;=(\mathbf{n}\cdot \mathbf{v})\mathbf{n}+\cos\theta\ (\mathbf{v}-(\mathbf{n}\cdot\mathbf{v})\mathbf{n})+\sin\theta\ (\mathbf{n}\times\mathbf{v}) \\
\\
&amp;=\cos\theta\ \mathbf{v}+(1-\cos\theta)(\mathbf{n}\cdot\mathbf{v})\mathbf{n}+\sin\theta\ (\mathbf{n}\times\mathbf{v})
\end{align*}
\end{split}\]</div>
<p>As you can see, the orthogonal component <span class="math notranslate nohighlight">\(\mathbf{v}_\bot\)</span> has disappeared from the equation, so we can compute any rotation by knowing only the vector to rotate <span class="math notranslate nohighlight">\((\mathbf{v})\)</span>, the angle of rotation <span class="math notranslate nohighlight">\((\theta)\)</span>, and the unit vector <span class="math notranslate nohighlight">\((\mathbf{n})\)</span> indicating the axis of rotation.</p>
<p>At this point, we can transform the standard basis vectors to compute the row vectors that make up the rotation matrix <span class="math notranslate nohighlight">\(\mathbf{R}_\mathbf{n}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
R_\mathbf{n}(\mathbf{i})&amp;=\big(\cos\theta+(1-\cos\theta)\ x^2,\quad(1-\cos\theta)\ xy+\sin\theta\ z,\quad(1-\cos\theta)\ xz-\sin\theta\ y\big) \\ 
\\
R_\mathbf{n}(\mathbf{j})&amp;=((1-\cos\theta)\ xy-\sin\theta\ z,\quad \cos\theta+(1-\cos\theta)\ y^2,\quad(1-\cos\theta)\ yz+\sin\theta\ x) \\
\\
R_\mathbf{n}(\mathbf{k})&amp;=((1-\cos\theta)\ xz+\sin\theta\ y,\quad(1-\cos\theta)\ yz-\sin\theta\ x,\quad\cos\theta+(1-\cos\theta)\ z^2)
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{n}=(x, y, z)\)</span>, <span class="math notranslate nohighlight">\(\mathbf{i}=(1,0,0)\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}=(0,1,0)\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{k}=(0,0,1)\)</span>. <br>
Therefore, we have that</p>
<div class="math notranslate nohighlight">
\[\mathbf{R}_\mathbf{n}=\left\lbrack\matrix{c+(1-c)x^2&amp;(1-c)xy+sz&amp;(1-c)xz-sy\cr (1-c)xy-sz&amp;c+(1-c)y^2&amp;(1-c)yz+sx\cr (1-c)xz+sy&amp;(1-c)yz-sx&amp;c+(1-c)z^2}\right\rbrack\]</div>
<p>where <span class="math notranslate nohighlight">\(c=\cos\theta\)</span>, and <span class="math notranslate nohighlight">\(s=sin\theta\)</span>.<br>
For example, if we want to rotate about the x-, y- and z- axes, we need to set <span class="math notranslate nohighlight">\(\mathbf{n}=\mathbf{i}=(1,0,0)\)</span>, <span class="math notranslate nohighlight">\(\mathbf{n}=\mathbf{j}=(0,1,0)\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{n}=\mathbf{k}=(0,0,1)\)</span>, respectively. So, the corresponding rotation matrices are</p>
<div class="math notranslate nohighlight">
\[\mathbf{R}_x=\left\lbrack\matrix{1&amp;0&amp;0\cr 0&amp;\cos\theta&amp;\sin\theta\cr 0&amp;-\sin\theta&amp;\cos\theta}\right\rbrack\quad\quad\quad\mathbf{R}_y=\left\lbrack\matrix{\cos\theta&amp;0&amp;-\sin\theta\cr 0&amp;1&amp;0\cr \sin\theta&amp;0&amp;\cos\theta}\right\rbrack\quad\quad\quad\mathbf{R}_z=\left\lbrack\matrix{\cos\theta&amp;\sin\theta&amp;0\cr -\sin\theta&amp;\cos\theta&amp;0\cr 0&amp;0&amp;1}\right\rbrack\]</div>
<div class="proof example admonition" id="example-1">
<p class="admonition-title"><span class="caption-number">Example 3 </span></p>
<section class="example-content" id="proof-content">
<p>Given a minimum point <span class="math notranslate nohighlight">\(\mathbf{p}=(-2,0,-2)\)</span> and a maximum point <span class="math notranslate nohighlight">\(\mathbf{q}=(2,0,2)\)</span> of a square, suppose you want to rotate it <span class="math notranslate nohighlight">\(-45°\)</span> clockwise (that is, <span class="math notranslate nohighlight">\(45°\)</span> counterclockwise ) about the y-axis. The corresponding rotation matrix is:</p>
<div class="math notranslate nohighlight">
\[\mathbf{R}_y=\left\lbrack\matrix{\cos\theta&amp;0&amp;-\sin\theta\cr 0&amp;1&amp;0\cr \sin\theta&amp;0&amp;\cos\theta}\right\rbrack=\left\lbrack\matrix{\cos{(-45°)}&amp;0&amp;-\sin{(-45°)}\cr 0&amp;1&amp;0\cr \sin{(-45°)}&amp;0&amp;\cos{(-45°)}}\right\rbrack=\left\lbrack\matrix{1/\sqrt{2}&amp;0&amp;1/\sqrt{2}\cr 0&amp;1&amp;0\cr -1/\sqrt{2}&amp;0&amp;1/\sqrt{2}}\right\rbrack\]</div>
<p>To rotate the square we need to multiply <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> by the rotation matrix <span class="math notranslate nohighlight">\(\mathbf{R}_y\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\left\lbrack\matrix{-2&amp;0&amp;-2}\right\rbrack\left\lbrack\matrix{1/\sqrt{2}&amp;0&amp;1/\sqrt{2}\cr 0&amp;1&amp;0\cr -1/\sqrt{2}&amp;0&amp;1/\sqrt{2}}\right\rbrack&amp;=\left\lbrack\matrix{0&amp;0&amp;-2.83}\right\rbrack \\ 
\\
\quad\left\lbrack\matrix{2&amp;0&amp;2}\right\rbrack\left\lbrack\matrix{1/\sqrt{2}&amp;0&amp;1/\sqrt{2}\cr 0&amp;1&amp;0\cr -1/\sqrt{2}&amp;0&amp;1/\sqrt{2}}\right\rbrack&amp;=\left\lbrack\matrix{0&amp;0&amp;2.83}\right\rbrack
\end{align*}
\end{split}\]</div>
<p>The following illustration shows the result of these transformations</p>
<figure class="align-default">
<img alt="../../../_images/rotation.png" src="../../../_images/rotation.png" />
</figure>
</section>
</div><p>You can easily verify that the rows of <span class="math notranslate nohighlight">\(\mathbf{R}_x\)</span> are unit vectors and orthogonal to each other (i.e., they make up an orthonormal set). The same applies to the rows of <span class="math notranslate nohighlight">\(\mathbf{R}_y\)</span>, <span class="math notranslate nohighlight">\(\mathbf{R}_z\)</span> and the general rotation matrix <span class="math notranslate nohighlight">\(\mathbf{R}_\mathbf{n}\)</span> (although, this last one is a little trickier to prove). A matrix whose rows compose an orthonormal set is called orthogonal. Orthogonal matrices are of particular interest since their inverse is equal to their transpose. That is, we have that</p>
<div class="math notranslate nohighlight">
\[\mathbf{R}_\mathbf{n}^{-1}=\mathbf{R}_\mathbf{n}^T=\left\lbrack\matrix{c+(1-c)x^2 &amp; (1-c)xy-sz &amp; (1-c)xz+sy \cr  (1-c)xy+sz &amp; c+(1-c)y^2 &amp; (1-c)yz-sx \cr  (1-c)xz-sy &amp; (1-c)yz+sx &amp; c+(1-c)z^2}\right\rbrack\]</div>
<br>
</section>
</section>
<section id="affine-transformations">
<h2>Affine transformations<a class="headerlink" href="#affine-transformations" title="Link to this heading">#</a></h2>
<p>Now that we know how to scale and rotate vectors, we’d also like to move them. However, we face two challenges when it comes to moving vectors:</p>
<ul class="simple">
<li><p>We certainly can use translation to move bound vectors (points, e.g., vertex positions) to relocate 3D objects in the scene. However, for free vectors, this transformation doesn’t make any sense since direction and magnitude don’t change after a translation (the point of application for free vectors is irrelevant). Therefore, we need a way to distinguish between points (bound vectors) and (free) vectors.</p></li>
<li><p>Moving a point can’t be expressed as a linear combination of the standard basis vectors. In other words, translation is not a linear transformation, so we can’t associate a <span class="math notranslate nohighlight">\(3\times 3\)</span> matrix with it. Fortunately, we can still find a way to incorporate translations into our matrix equation <span class="math notranslate nohighlight">\(\mathbf{w}=\mathbf{vM}\)</span>.</p></li>
</ul>
<p>Affine transformations extend linear ones by adding translations. The next section will explore this type of transformation, aiming to resolve the aforementioned issues.</p>
<section id="translation">
<h3>Translation<a class="headerlink" href="#translation" title="Link to this heading">#</a></h3>
<p>To move a bound vector (point) <span class="math notranslate nohighlight">\(\mathbf{p}=(p_x, p_y, p_z)\)</span> using a translation <span class="math notranslate nohighlight">\(T\)</span>, we simply add a displacement vector <span class="math notranslate nohighlight">\(\mathbf{t}=(t_x, t_y, t_z)\)</span> to the point.</p>
<div class="math notranslate nohighlight">
\[T(\mathbf{p})=\mathbf{p}+\mathbf{t}=(p_x+t_x,\ p_y+t_y,\ p_z+t_z)\tag{2}\label{eq:ATransforms2}\]</div>
<p>For example, let’s consider a 2D point <span class="math notranslate nohighlight">\(\mathbf{p}=(3, 3)\)</span>. If we want to translate it by <span class="math notranslate nohighlight">\(+5\)</span> units along the x-axis and <span class="math notranslate nohighlight">\(+2\)</span> units along the y-axis, we can add the displacement vector <span class="math notranslate nohighlight">\(\mathbf{t}=(5, 2)\)</span> to <span class="math notranslate nohighlight">\(\mathbf{p}\)</span>, as shown in the following illustration.</p>
<figure class="align-default">
<img alt="../../../_images/translation.png" src="../../../_images/translation.png" />
</figure>
<p>At the same time, we can translate the frame by using the same displacement vector <span class="math notranslate nohighlight">\(\mathbf{t}\)</span>, that now specifies the offset where to move the origin of the translated frame A (the starting one) with respect to the original frame B (the new one). In frame A, the coordinates of the bound vector (point) <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> are still the same, while in frame B the coordinates of <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> can be seen as the sum of <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{t}\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/translation2.png" src="../../../_images/translation2.png" />
</figure>
<p>So, it seems that translation of vectors and translation of coordinate systems are mathematically equivalent, just like with linear transformations (in the next section we will formally prove that this is true in general for affine transformations). This means that we can translate a frame to apply the same transformation to vectors defined in that frame. So far so good, but the question is: can we find a <span class="math notranslate nohighlight">\(3\times 3\)</span> matrix <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> to associate with translations in 3D spaces? Unfortunately, the answer is no.</p>
<p>To understand why, just take a look again at the definition of <span class="math notranslate nohighlight">\(T(\mathbf{p})\)</span> provided in equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms2}\)</span>. It’s a simple sum of vectors. On the other hand, in a vector-matrix multiplication, we have the dot product of two vectors (the row vector and a column of the matrix). Therefore, there is no way we can find a <span class="math notranslate nohighlight">\(3\times 3\)</span> matrix <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> so that <span class="math notranslate nohighlight">\(\mathbf{w}=\mathbf{p}+\mathbf{t}=\mathbf{pT}\)</span>. This is due to the fact that translations are not linear transformations.</p>
<div class="dropdown admonition">
<p class="admonition-title">Proof</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
T(\mathbf{u}+\mathbf{v})&amp;=(u_x+v_x+t_x,\ u_y+v_y+t_y,\ u_z+v_z+t_z) \\ 
\\
T(\mathbf{u})+T(\mathbf{v})&amp;=(u_x+t_x,\ u_y+t_y,\ u_z+t_z)+(v_x+t_x,\ v_y+t_y,\ v_z+t_z) \\
&amp;=(u_x+v_x+2t_x,\ u_y+v_y+2t_y,\ u_z+v_z+2t_z)
\end{align*}
\end{split}\]</div>
<p>Therefore, <span class="math notranslate nohighlight">\(T(\mathbf{u}+\mathbf{v}) \neq T(\mathbf{u})+T(\mathbf{v})\)</span>, indicating that the first condition of linearity does not hold.</p>
</div>
<p>However, we can still find a way to incorporate translations into our matrix equation <span class="math notranslate nohighlight">\(\mathbf{w}=\mathbf{vM}\)</span> by employing homogeneous coordinates. This allows us to mantain the form <span class="math notranslate nohighlight">\(\mathbf{w}=\mathbf{p}+\mathbf{t}=\mathbf{pT}\)</span>, where <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> is a translation matrix.</p>
<br>
</section>
</section>
<section id="homogeneous-coordinates">
<h2>Homogeneous coordinates<a class="headerlink" href="#homogeneous-coordinates" title="Link to this heading">#</a></h2>
<p>As explained in <a class="reference internal" href="vectors.html"><span class="std std-doc">Vectors</span></a>, homogeneous coordinates introduce an “extra” coordinate. This means that starting from a 3D Cartesian systems, we step into the 4-th dimension. Fortunately, we just pop in to pick up what we need, and leave immediately after.</p>
<p>A point in 3D space can be represented in homogeneous coordinates by the tuple <span class="math notranslate nohighlight">\((x,y,z,w)\)</span>, where the related 3D Cartesian coordinates are <span class="math notranslate nohighlight">\((x/w,\ y/w,\ z/w,\ w/w)\)</span>. So, the generic 3D Cartesian coordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span> can be written as <span class="math notranslate nohighlight">\((x, y, z, 1)\)</span> in homogeneous coordinates. This way, we can use the first three components as regular 3D Cartesian coordinates, and the last component to differentiate between points and vectors.</p>
<ul class="simple">
<li><p>Points: <span class="math notranslate nohighlight">\(\ (x, y, z, 1)\)</span></p></li>
<li><p>Vectors: <span class="math notranslate nohighlight">\(\ (x, y, z, 0)\)</span></p></li>
</ul>
<p>We need this distinction between points and vectors as we want to apply translations to points without affecting vectors. Now, since we are using four components, we can try to find a <span class="math notranslate nohighlight">\(4\times 4\)</span> matrix <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> associated with translations in 3D spaces. Let’s start with the identity matrix, using the offset of the translated frame <span class="math notranslate nohighlight">\(\mathbf{t}=(t_x, t_y, t_z, 1)\)</span> as the last row.</p>
<div class="math notranslate nohighlight">
\[\mathbf{T}=\left\lbrack\matrix{1&amp;0&amp;0&amp;0\cr 0&amp;1&amp;0&amp;0\cr 0&amp;0&amp;1&amp;0\cr t_x&amp;t_y&amp;t_z&amp;1}\right\rbrack\]</div>
<p>Let’s see what happens if we multiply a generic point <span class="math notranslate nohighlight">\(\mathbf{p}=(p_x, p_y, p_z, 1)\)</span> by <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}=\mathbf{pT}=\left\lbrack\matrix{p_x &amp; p_y &amp; p_z &amp; 1}\right\rbrack\left\lbrack\matrix{1&amp;0&amp;0&amp;0\cr 0&amp;1&amp;0&amp;0\cr 0&amp;0&amp;1&amp;0\cr t_x &amp; t_y &amp; t_z &amp; 1}\right\rbrack=(p_x+t_x,\ p_y+t_y,\ p_z+t_z,\ 1)=\mathbf{p}+\mathbf{t}\]</div>
<p>That’s exactly the definition of <span class="math notranslate nohighlight">\(T(\mathbf{p})\)</span> in equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms2}\)</span>, but expressed in homogeneous coordinates (that is, with the last component equal to <span class="math notranslate nohighlight">\(1\)</span>). Now, let’s see what happens if we multiply a generic vector <span class="math notranslate nohighlight">\(\mathbf{v}=(v_x, v_y, v_z, 0)\)</span> by <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}=\mathbf{vT}=\left\lbrack\matrix{v_x &amp; v_y &amp; v_z &amp; 0}\right\rbrack\left\lbrack\matrix{1&amp;0&amp;0&amp;0\cr 0&amp;1&amp;0&amp;0\cr 0&amp;0&amp;1&amp;0\cr t_x &amp; t_y &amp; t_z &amp; 1}\right\rbrack=(v_x, v_y, v_z, 0)=\mathbf{v}\]</div>
<p>The vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is not affected by the translation. It looks like we just found a matrix associated with translation of points, but that does not affect directions. Of course, the inverse of the translation matrix is</p>
<div class="math notranslate nohighlight">
\[\mathbf{T}^{-1}=\left\lbrack\matrix{1&amp;0&amp;0&amp;0\cr 0&amp;1&amp;0&amp;0\cr 0&amp;0&amp;1&amp;0\cr -t_x&amp;-t_y&amp;-t_z&amp;1}\right\rbrack\]</div>
<p>However, we’d like to also include linear transformations (scaling and rotation). For this purpose, we can try to embed the <span class="math notranslate nohighlight">\(3\times 3\)</span> matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> associated with linear transformations in the upper left position of <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}=\left\lbrack\matrix{A_{00}&amp;A_{01}&amp;A_{02}&amp;0\cr A_{10}&amp;A_{11}&amp;A_{12}&amp;0\cr A_{20}&amp;A_{21}&amp;A_{22}&amp;0\cr t_x&amp;t_y&amp;t_z&amp;1}\right\rbrack\]</div>
<p>Now, if we multiply a generic vector <span class="math notranslate nohighlight">\(\mathbf{v}=(x, y, z, 0)\)</span> by <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> we have</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}=\mathbf{vM}=\left\lbrack\matrix{x&amp;y&amp;z&amp;0}\right\rbrack.\left\lbrack\matrix{\mathbf{f}\cr \mathbf{g}\cr \mathbf{h}\cr \mathbf{t}}\right\rbrack=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}+0\mathbf{t}=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{f}=(A_{00}, A_{01}, A_{02}, 0)\)</span>, <span class="math notranslate nohighlight">\(\mathbf{g}=(A_{10}, A_{11}, A_{12}, 0)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{h}=(A_{20}, A_{21}, A_{22}, 0)\)</span> are the linearly transformed standard basis vectors <span class="math notranslate nohighlight">\(\mathbf{i}=(1,0,0,0)\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}=(0,1,0,0)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{k}=(0,0,1,0)\)</span>, while <span class="math notranslate nohighlight">\(\mathbf{t}=(t_x, t_y, t_z, 1)\)</span> is still the position of the translated frame (the starting one) with respect to the original frame (the new one).</p>
<p>As you can see, the translation doesn’t affect the vector, and the result is the same we showed in equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms1}\)</span>: <span class="math notranslate nohighlight">\(\mathbf{w}=\mathbf{vM}\)</span>. Indeed, when you transform vectors with <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>, these can only be affected by the linear transformation embedded within the matrix. Moreover, the result is still a vector: the last component is zero because it’s the result of the dot product between <span class="math notranslate nohighlight">\(\mathbf{v}=(v_x, v_y, v_z, 0)\)</span> and <span class="math notranslate nohighlight">\((0,0,0,1)\)</span>, the last column of <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>.</p>
<p>On the other hand, if we multiply a generic point <span class="math notranslate nohighlight">\(\mathbf{q}=(x, y, z, 1)\)</span> by <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\mathbf{p}=\mathbf{q}\mathbf{M}=\left\lbrack\matrix{x&amp;y&amp;z&amp;1}\right\rbrack\left\lbrack\matrix{\mathbf{f}\cr \mathbf{g}\cr \mathbf{h}\cr \mathbf{t}}\right\rbrack=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}+1\mathbf{t}=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}+\mathbf{t}\quad\quad\tag{3}\label{eq:ATransforms3} \\
\end{align*}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{p}=\mathbf{q}\mathbf{M}=\left\lbrack\matrix{x&amp;y&amp;z&amp;1}\right\rbrack\left\lbrack\matrix{\mathbf{f}\cr \mathbf{g}\cr \mathbf{h}\cr \mathbf{t}}\right\rbrack=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}+1\mathbf{t}=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}+\mathbf{t} \\
\tag{6}\label{eq:ATransforms6}
\end{split}\]</div>
<p>Here, we transform <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> with a linear transformation, which results in an intermediate vector <span class="math notranslate nohighlight">\(\mathbf{q}_1=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}\)</span> to which we add the translation <span class="math notranslate nohighlight">\(\mathbf{t}\)</span>. That’s exactly what we stated in equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms2}\)</span>: a translation is the sum of a point ad a vector. However, in equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms3}\)</span> the point is <span class="math notranslate nohighlight">\(\mathbf{t}\)</span>, as it specifies the origin of the starting frame with respect to the new one. Also, the result is still a point: the last component is <span class="math notranslate nohighlight">\(1\)</span> because it’s the result of the dot product between <span class="math notranslate nohighlight">\(\mathbf{q}=(x, y, z, 1)\)</span> and <span class="math notranslate nohighlight">\((0, 0, 0, 1)\)</span>, the last row of <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>.</p>
<p>Furthermore, the difference of two points is the vector from a point to the other one. Indeed, from equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms3}\)</span>, we have that</p>
<div class="math notranslate nohighlight">
\[\mathbf{p}-\mathbf{t}=x\mathbf{f}+y\mathbf{g}+z\mathbf{h}\]</div>
<p>which is a vector, as it’s not bound to the origin of the frame of reference (see the illustration below, on the left side). On the other hand, the sum of two points is a point as well, but it doesn’t make any sense (unlike the sum of two vectors, which is the resultant force, direction or speed).</p>
<figure class="align-default">
<img alt="../../../_images/vector-point-sum.png" src="../../../_images/vector-point-sum.png" />
</figure>
<p>In conclusion, the matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> we built in this section can be used to transform both vectors and points with affine transformations, as it embeds a linear transformation, plus a translation. The first three rows represent the transformed standard basis vectors, while the four-th is a displacement that specifies the origin of the starting frame with respect to a new one. Most importantly, <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> still allows us to express the coordinates of a vector in a starting frame with respect to a new one. As explained at the beginning of the tutorial, this implies that <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is a matrix that allows us to go from a frame to another, which means that change of coordinates and change of coordinate system are still mathematically equivalent in the context of affine transformations.</p>
<br>
</section>
<section id="composition-of-transformations">
<h2>Composition of transformations<a class="headerlink" href="#composition-of-transformations" title="Link to this heading">#</a></h2>
<p>Imagine you want to scale, rotate and translate a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, obtaining a vector <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>. Mathematically, this can be expressed in matrix form as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}=((\mathbf{vS})\mathbf{R})\mathbf{T})\tag{4}\label{eq:ATransforms4}\]</div>
<p>The vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and the resultant vector <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> can be considered row vectors of dimension <span class="math notranslate nohighlight">\(1\times n\)</span>, while the matrices <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> are all <span class="math notranslate nohighlight">\(n\times n\)</span>.</p>
<p>In vector-matrix multiplication, we need to perform <span class="math notranslate nohighlight">\((2n-1)\)</span> operations for each component of the resultant vector: <span class="math notranslate nohighlight">\((n-1)\)</span> sums and <span class="math notranslate nohighlight">\(n\)</span> products. So, to obtain the total operations involved, we must multiply <span class="math notranslate nohighlight">\((2n-1)\)</span> by the <span class="math notranslate nohighlight">\(n\)</span> components of the resultant vector. Therefore, we have <span class="math notranslate nohighlight">\(n(2n-1)\)</span> operations to perform each vector-matrix multiplication. In equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms4}\)</span>, we need to perform three of these multiplications, so the total cost is <span class="math notranslate nohighlight">\(3n(2n-1)=6n^2-3n=O(n^2)\)</span>.</p>
<p>However, thanks to the associative property of matrix multiplication we can re-write equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms4}\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}=(((\mathbf{vS})\mathbf{R})\mathbf{T})=(\mathbf{v}(\mathbf{SR})\mathbf{T})=\mathbf{v}(\mathbf{SRT})\tag{5}\label{eq:ATransforms5}\]</div>
<p>Now, we have two matrix multiplications and a vector-matrix multiplication.<br>
Each matrix multiplication needs <span class="math notranslate nohighlight">\((2n-1)\)</span> operations for each element of the resultant matrix. So, to obtain the total operations involved, we must multiply <span class="math notranslate nohighlight">\((2n-1)\)</span> by the <span class="math notranslate nohighlight">\(n^2\)</span> elements of the resultant matrix. Therefore, we have <span class="math notranslate nohighlight">\((2n-1)n^2\)</span> operations to perform a matrix multiplication. In equation <span class="math notranslate nohighlight">\(\eqref{eq:ATransforms5}\)</span>, we have two of these multiplications, plus a vector-matrix multiplication, so the total cost is <span class="math notranslate nohighlight">\(2(2n^3-n^2)+n(2n-1)=4n^3-n=O(n^3)\)</span>.</p>
<p>It seems that we need more operations to perform if we first multiply the matrices. However, imagine you want to transform 10 thousand vectors by the same matrices <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>. In the first case we need to perform <span class="math notranslate nohighlight">\(10000(3n(2n-1))\)</span> operations, while in the second case we only need <span class="math notranslate nohighlight">\(10000(n(2n-1))+2(2n^3-n^2)\)</span> operations, as the double matrix multiplication <span class="math notranslate nohighlight">\((\mathbf{SRT})\)</span> must be computed only once. That is, we can reuse the result of <span class="math notranslate nohighlight">\((\mathbf{SRT})\)</span> as a matrix to transform every vector. For example, if <span class="math notranslate nohighlight">\(n=4\)</span>, we have <span class="math notranslate nohighlight">\(10000(3n(2n-1))=840\text{k}\)</span>, while <span class="math notranslate nohighlight">\(10000(n(2n-1))+2(2n^3-n^2)=280\text{k}\)</span>.</p>
<p>In conclusion, it is strongly recommended to transform vectors with a matrix which is a composition of all the transformations you want to apply to the vectors.</p>
<br>
</section>
<section id="transformation-in-directx">
<h2>Transformation in DirectX<a class="headerlink" href="#transformation-in-directx" title="Link to this heading">#</a></h2>
<p>DirectXMath offers convenient helper functions for constructing <span class="math notranslate nohighlight">\(4\times 4\)</span> matrices to transform (i.e., scale, rotate and translate) both points (e.g., vertex positions) and vectors (e.g., light directions) in homogeneous coordinates. These functions often come in two flavors:</p>
<ul class="simple">
<li><p><strong>Scalar implementation</strong>: Written in standard C++, utilizing scalar operations. It works on any CPU regardless of its architecture, but may be slower than alternative options.</p></li>
<li><p><strong>SIMD-accelerated implementation</strong>: Leverages the power of Single Instruction, Multiple Data (SIMD) instructions available on modern CPUs, exposed by intrinsics functions provided by the Microsoft C++ compiler. This allows the CPU to perform calculations on multiple data elements simultaneously, resulting in significant performance gains.</p></li>
</ul>
<p><strong>XMMatrixScaling</strong> returns a matrix associated with a scaling operation, similar to the one examined in <a class="reference internal" href="#transforms-scaling-label"><span class="std std-ref">Scaling</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="n">XMMATRIX</span><span class="w"> </span><span class="n">XM_CALLCONV</span><span class="w"> </span><span class="n">XMMatrixScaling</span>
<span class="p">(</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ScaleX</span><span class="p">,</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ScaleY</span><span class="p">,</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ScaleZ</span>
<span class="p">)</span><span class="w"> </span><span class="k">noexcept</span>
<span class="p">{</span>
<span class="cp">#if defined(_XM_NO_INTRINSICS_)</span>

<span class="w">    </span><span class="n">XMMATRIX</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScaleX</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>

<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScaleY</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>

<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScaleZ</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>

<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>

<span class="cp">#elif defined(_XM_SSE_INTRINSICS_)</span>
<span class="w">    </span><span class="n">XMMATRIX</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set_ps</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ScaleX</span><span class="p">);</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set_ps</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ScaleY</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_mm_set_ps</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ScaleZ</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_XMIdentityR3</span><span class="p">.</span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>

<span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the previous code snippet, <code class="docutils literal notranslate"><span class="pre">g_XMIdentityR3</span></code> is a <strong>XMVECTORF32</strong> global constant defined as <code class="docutils literal notranslate"><span class="pre">{0.0f,</span> <span class="pre">0.0f,</span> <span class="pre">0.0f,</span> <span class="pre">1.0f}</span></code>. In contrast, the <code class="docutils literal notranslate"><span class="pre">_mm_set_ps</span></code> intrinsic function returns a <strong>__m128</strong> value initialized (in a single instruction) using the floating-point values provided as arguments. Below, you’ll find the declaration of the <code class="docutils literal notranslate"><span class="pre">_mm_set_ps</span></code> function, along with a concise explanation of how its parameters map to the bits of the return value (denoted as <code class="docutils literal notranslate"><span class="pre">dst</span></code>). In particular, observe that the last parameter <code class="docutils literal notranslate"><span class="pre">e0</span></code> is used to initialize the least significant 32 bits of the returned <strong>__m128</strong> value, corresponding to the bits of the first component of a 4-component vector of floating-point values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__m128</span> <span class="n">_mm_set_ps</span> <span class="p">(</span><span class="nb">float</span> <span class="n">e3</span><span class="p">,</span> <span class="nb">float</span> <span class="n">e2</span><span class="p">,</span> <span class="nb">float</span> <span class="n">e1</span><span class="p">,</span> <span class="nb">float</span> <span class="n">e0</span><span class="p">);</span>

<span class="n">dst</span><span class="p">[</span><span class="mi">31</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">e0</span>
<span class="n">dst</span><span class="p">[</span><span class="mi">63</span><span class="p">:</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="n">e1</span>
<span class="n">dst</span><span class="p">[</span><span class="mi">95</span><span class="p">:</span><span class="mi">64</span><span class="p">]</span>  <span class="o">=</span> <span class="n">e2</span>
<span class="n">dst</span><span class="p">[</span><span class="mi">127</span><span class="p">:</span><span class="mi">96</span><span class="p">]</span> <span class="o">=</span> <span class="n">e3</span>
</pre></div>
</div>
<br>
<p>[WIP]</p>
<br>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Tutorials\Appendices\01-MathBasics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="matrices.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Matrices</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-transformations">Linear transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scaling">Scaling</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation">Rotation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#affine-transformations">Affine transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translation">Translation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#homogeneous-coordinates">Homogeneous coordinates</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#composition-of-transformations">Composition of transformations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#transformation-in-directx">Transformation in DirectX</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By P. A. Minerva
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>