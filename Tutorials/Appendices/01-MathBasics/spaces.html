
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Spaces &#8212; Learn DirectX</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=bd9e20870c6007c4c509"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=afe5de03"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Tutorials/Appendices/01-MathBasics/spaces';</script>
    <link rel="canonical" href="https://github.com/PAMinerva/LearnDirectX/Tutorials/Appendices/01-MathBasics/spaces.html" />
    <link rel="icon" href="../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="prev" title="Transformations" href="transformations.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <header>


  <div class="bd-header-announcement container-fluid bd-header-announcement">
    <div class="bd-header-announcement__content">🚧 This documentation is a work in progress! 🚧</div>
  </div>

  
    <div class="bd-header navbar navbar-expand-lg bd-navbar">
    </div>
  
  </header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../presentation.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Learn DirectX - Home"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Learn DirectX - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../presentation.html">
                    Welcome to Learn DirectX
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../00-Intro/intro-and-prerequisites.html">Introduction and Prerequisites</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Hello DirectX</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../01-HelloWorld/hello-world.html">Hello World</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-window.html">Hello Window</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-triangle.html">Hello Triangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-bundles.html">Hello Bundles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-cbs.html">Hello Constant Buffers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-texture.html">Hello Texture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-frame-buffering.html">Hello Frame Buffering</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="math-basics.html">Math Basics</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="vectors.html">Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html">Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="transformations.html">Transformations</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Spaces</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/PAMinerva/LearnDirectX" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/PAMinerva/LearnDirectX/issues/new?title=Issue%20on%20page%20%2FTutorials/Appendices/01-MathBasics/spaces.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/Tutorials/Appendices/01-MathBasics/spaces.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Spaces</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#object-space">Object space</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#world-space-and-world-matrix">World space and World matrix</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#view-space-and-view-matrix">View space and View matrix</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#ndc-space-and-projection-matrix">NDC space and Projection matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#perspective-projection">Perspective projection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#general-case">General case</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#perspective-division-and-clipping">Perspective division and clipping</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#depth-buffer-precision">Depth buffer precision</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#orthographic-projection">Orthographic projection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#projection-matrices-in-directx-wip">Projection matrices in DirectX [WIP]</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="spaces">
<h1>Spaces<a class="headerlink" href="#spaces" title="Link to this heading">#</a></h1>
<p>The magic of computer graphics lies in the ability to transform and manipulate objects within cartesian coordinate systems, also known as spaces for brevity. Indeed, a fundamental concept that forms the backbone of many graphics pipelines is the transformation of 3D objects to represent them in various spaces in order to bring virtual scene to be shown on the screen.</p>
<p>In <a class="reference internal" href="transformations.html"><span class="std std-doc">Transformations</span></a>, we showed that to transform a points and vectors we can transform the basis vectors representing the starting frame, so that we can express the coordinates with respect to a new space. Building upon this foundation, it’s now interesting to look at the common spaces typically employed in the graphics pipeline and how to go from a space to another as well in order to project the 3D scenes onto a 2D surface before showing the result on the screen.</p>
<p>From the initial local space where each object is defined, to the all-encompassing world space, and the camera space that offers a unique perspective, each space plays a crucial role in the intricate process of rendering. For a more extensive and detailed presentation on spaces used in computer graphics and transformations to go from one space to another, you may find valuable information in <span id="id1">[<a class="reference internal" href="#id13" title="S. Marschner and P. Shirley. Fundamentals of Computer Graphics. CRC Press, 4th edition, 2022.">MS22</a>]</span>.</p>
<section id="object-space">
<h2>Object space<a class="headerlink" href="#object-space" title="Link to this heading">#</a></h2>
<p>The object space, also known as local space, is the frame in which 3D objects\meshes are defined. When creating 3D objects, graphic artists often work in a convenient space that simplifies vertex modeling by providing symmetry with respect to the origin of the coordinate system.</p>
<figure class="align-default">
<img alt="../../../_images/object-space.jpg" src="../../../_images/object-space.jpg" />
</figure>
<p>For instance, consider the modeling of a sphere. It is much easier to place all the vertices at an equal distance from the origin, rather than using a random point as the sphere’s center. This intuitive choice is not only practical but can also be mathematically justified.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
\text{Equation of the sphere with center in } (0,0,0):\quad &amp;x^2+y^2+z^2=r^2 \\ 
\\
\text{Equation of the sphere with center in } (x_0, y_0, z_0):\quad &amp;(x-x_0)^2+(y-y_0)^2+(z-z_0)^2=r^2
\end{flalign}
\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The local space is the frame where the vertices of a mesh are defined in the first place. These vertices are often stored in a file on disk and can be loaded into memory to create the vertex buffer, which is subsequently sent to the input assembler. Within this buffer, the vertices remain in their local space representation until the graphics pipeline performs the necessary transformations to convert the 3D objects they represent into a 2D representation to show on the screen.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Throughout this tutorial series, we’ll use a left-handed coordinate system where the y-axis points upwards to represent the object space. As explained in <a class="reference internal" href="vectors.html"><span class="std std-doc">Vectors</span></a>, this is completely arbitrary and you can choose any configuration (z-up or y-up) and handedness that suits your needs.</p>
</div>
<br>
</section>
<section id="world-space-and-world-matrix">
<h2>World space and World matrix<a class="headerlink" href="#world-space-and-world-matrix" title="Link to this heading">#</a></h2>
<p>When the input assembler sends its output to the next stage (the vertex shader), we have vertices in local space that we want to place in a 3D global scene shared by all objects. The space of the global scene is called <strong>world space</strong>, and the transformation to go from local to world space is called <strong>world transformation</strong>. To represent the world space, we will use the same convention as the object space: left-handed system with the y-axis pointing upwards.</p>
<figure class="align-default">
<img alt="../../../_images/world-space.png" src="../../../_images/world-space.png" />
</figure>
<p>As we know, to go from a frame to another, we need to express the basis vectors of the starting frame with respect to the new frame. So, we can build a matrix <span class="math notranslate nohighlight">\(\mathbf{W}=\mathbf{SRT}\)</span> (a composition of three trasformations: a scaling, a rotation, and a translation) associated with the world transformation we want to apply to the local frame to get the coordinates of its basis vectors with respect to the world space. Therefore, <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> is the matrix to go from local to world space, and that allows us to put an object (or rather, its vertices) in the global scene. For this reason, we call <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> the world matrix.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>We hardly place every object in the same location of the world space, so <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> will likely be different from object to object.</p>
<figure class="align-default">
<img alt="../../../_images/local2world.png" src="../../../_images/local2world.png" />
</figure>
</div>
<p>Thus, we can define <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> as</p>
<div class="math notranslate nohighlight">
\[\mathbf{W}=\mathbf{SRT}=\left\lbrack\matrix{f_x&amp;f_y&amp;f_z&amp;0\cr g_x&amp;g_y&amp;g_z&amp;0\cr h_x&amp;h_y&amp;h_z&amp;0\cr t_x&amp;t_y&amp;t_z&amp;1}\right\rbrack\]</div>
<p>where the first three rows of <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> are the scaled and rotated basis vectors of the local space with respect to the world space, while the last row is the translation of the origin of the local space (again, with respect to the world space).</p>
<div class="proof example admonition" id="example-0">
<p class="admonition-title"><span class="caption-number">Example 4 </span></p>
<section class="example-content" id="proof-content">
<p>Given a cube in local space, suppose you want to double its size, rotate it by <span class="math notranslate nohighlight">\(45°\)</span> clockwise about the y-axis, and move it at <span class="math notranslate nohighlight">\((10,0,5)\)</span> in the world space. Therefore, we must transform all the vertices of the cube using the following world matrix:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\mathbf{W}=\mathbf{SRT}&amp;=\left\lbrack\matrix{2&amp;0&amp;0&amp;0\cr 0&amp;2&amp;0&amp;0\cr 0&amp;0&amp;2&amp;0\cr 0&amp;0&amp;0&amp;1}\right\rbrack\left\lbrack\matrix{\sqrt2/2&amp;0&amp;-\sqrt2/2&amp;0\cr 0&amp;1&amp;0&amp;0\cr \sqrt2/2&amp;0&amp;\sqrt2/2&amp;0\cr 0&amp;0&amp;0&amp;1}\right\rbrack\left\lbrack\matrix{1&amp;0&amp;0&amp;0\cr 0&amp;1&amp;0&amp;0\cr 0&amp;0&amp;1&amp;0\cr 10&amp;0&amp;5&amp;1}\right\rbrack \\ 
\\
&amp;=\left\lbrack\matrix{\sqrt2&amp;0&amp;-\sqrt2&amp;0\cr 0&amp;2&amp;0&amp;0\cr \sqrt2&amp;0&amp;\sqrt2&amp;0\cr 10&amp;0&amp;5&amp;1}\right\rbrack
\end{align*}
\end{split}\]</div>
<p>The image below shows a 2D cross-section of the scene, obtained by looking down along the positive y-axis. Note that the first three rows of the <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> matrix are the scaled and rotated basis vectors of the local space in world coordinates (that is, whose coordinates are with respect to the world space), while the fourth row is the position (point) of the origin of the translated local space (again, in world coordinates). Based on the information provided in <a class="reference internal" href="matrices.html"><span class="std std-doc">Matrices</span></a>, we can use <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> to transform the vertices of the cube in order to place it in the global scene.</p>
<figure class="align-default">
<img alt="../../../_images/example1.png" src="../../../_images/example1.png" />
</figure>
</section>
</div><br>
</section>
<section id="view-space-and-view-matrix">
<h2>View space and View matrix<a class="headerlink" href="#view-space-and-view-matrix" title="Link to this heading">#</a></h2>
<p>Once we apply the world transformation, all objects are in world space. However, we still require a specific viewpoint to observe the 3D scene. This space is typically called <strong>view space</strong>, or <strong>camera space</strong>, and to represent it, we’ll adopt a left-handed system similar to the ones used for local and world spaces, where the y-axis points upwards. To transition objects from world space to view space, we need to apply another transformation: the <strong>view transformation</strong>. This involves applying a <strong>view matrix</strong> (denoted by <span class="math notranslate nohighlight">\(\mathbf{V}\)</span>), which configures the camera’s position, orientation, and perspective within the global scene. By applying the view matrix, we effectively convert the coordinates of objects’ vertices from world space to view space, establishing the desired viewpoint for our 3D scene.</p>
<figure class="align-default">
<img alt="../../../_images/view-space.png" src="../../../_images/view-space.png" />
</figure>
<p>Unlike the world transformation, where each object typically requires a separate transformation, the view transformation usually employs the same view matrix for all objects in the global scene. This is because we generally aim for a consistent viewpoint to observe the entire 3D scene. In other words, it’s as if we can consider the entire scene, encompassing all the objects, as a single large object that needs to be transformed from world space to view space.</p>
<p>Now, to build the view matrix, we can start considering the camera as an ordinary object we can place in world space. So, we can use a world matrix <span class="math notranslate nohighlight">\(\mathbf{W}_c\)</span> to put the camera in the global space as the point of view from which to look at the scene.</p>
<div class="math notranslate nohighlight">
\[\mathbf{W}_c=\left\lbrack\matrix{f_x&amp;f_y&amp;f_z&amp;0\cr g_x&amp;g_y&amp;g_z&amp;0\cr h_x&amp;h_y&amp;h_z&amp;0\cr t_x&amp;t_y&amp;t_z&amp;1}\right\rbrack\]</div>
<p><span class="math notranslate nohighlight">\(\mathbf{W}_c\)</span> is the matrix that transforms from the local space of the camera to the world space. However, note that the local space of the camera is exactly the view space, the perspective from which we observe the scene. This means that <span class="math notranslate nohighlight">\(\mathbf{W}_c\)</span> is the matrix for transitioning from view space to world space. Therefore, we can simply compute the inverse <span class="math notranslate nohighlight">\(\mathbf{W}_c^{-1}\)</span> to get the view matrix allowing to go from world space to view space. In this case, computing the inverse is straightforward as <span class="math notranslate nohighlight">\(\mathbf{W}_c\)</span> is the composition of a rotation and a translation: <span class="math notranslate nohighlight">\(\mathbf{W}_c=\mathbf{RT}\)</span>. Indeed, it doesn’t make any sense to scale the camera since it’s a dummy object; we are only interested in the position and orientation of the view space. And we don’t need scaling in the inverse transformation either, as we’ve already scaled the objects during the world transformations, aiming to maintain their size in world space. Therefore, the first three rows of <span class="math notranslate nohighlight">\(\mathbf{W}_c\)</span> represent the rotations of the standard basis vectors of the view space relative to the world space (that is, in world coordinates), while the last row represents the position of the origin of the view space, in world coordinates as well. So, we have</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}=\mathbf{W}_c^{-1}=(\mathbf{RT})^{-1}=\mathbf{T}^{-1}\mathbf{R}^{-1}=\mathbf{T}^{-1}\mathbf{R}^{-T}=\left\lbrack\matrix{1&amp;0&amp;0&amp;0\cr 0&amp;1&amp;0&amp;0\cr 0&amp;0&amp;1&amp;0\cr {-t}_x&amp;-t_y&amp;-t_z&amp;1}\right\rbrack\left\lbrack\matrix{f_x&amp;g_x&amp;h_x&amp;0\cr f_y&amp;g_y&amp;h_y&amp;0\cr f_z&amp;g_z&amp;h_z&amp;0\cr 0&amp;0&amp;0&amp;1}\right\rbrack\]</div>
<p>Indeed, remember that the inverse of a rotation matrix is equivalent to its transpose (as explained in <a class="reference internal" href="matrices.html"><span class="std std-doc">Matrices</span></a>). Consequently, the view matrix <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> to go from world space to view space is</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}=\left\lbrack\matrix{f_x&amp;g_x&amp;h_x&amp;0\cr f_y&amp;g_y&amp;h_y&amp;0\cr f_z&amp;g_z&amp;h_z&amp;0\cr -\mathbf{t}\cdot\mathbf{f}&amp;-\mathbf{t}\cdot\mathbf{g}&amp;-\mathbf{t}\cdot\mathbf{h}&amp;1}\right\rbrack\]</div>
<p>It’s interesting to note that, since <span class="math notranslate nohighlight">\(\mathbf{f}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{g}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{t}\)</span> are all in world coordinates, we can compute the view matrix <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> from scratch by only using two points in the world space: the origin <span class="math notranslate nohighlight">\(\mathbf{O}_v\)</span> of the view space and a target point <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> indicating where the camera is aimed. To verify this, let’s start by observing that</p>
<div class="math notranslate nohighlight">
\[\mathbf{t}=\mathbf{O}_v\]</div>
<p>because both <span class="math notranslate nohighlight">\(\mathbf{O}_v\)</span> and <span class="math notranslate nohighlight">\(\mathbf{t}\)</span> represent the same geometric entity: the position of the view space in world coordinates.</p>
<p>Now, we need to calculate <span class="math notranslate nohighlight">\(\mathbf{f}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{h}\)</span>, which represent the transformations of the standard basis vectors <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> in the camera’s local space. Specifically, <span class="math notranslate nohighlight">\(\mathbf{h}\)</span>, the transformation of <span class="math notranslate nohighlight">\(\mathbf{k}\)</span>, points in the direction the camera is aimed (z-axis of the camera space in the image above). Therefore, we can calculate it simply by taking the difference between <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{O}_v\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{h}=\displaystyle\frac{\mathbf{T}-\mathbf{O}_v}{\vert\mathbf{T}-\mathbf{O}_v\vert}\]</div>
<p>Observe that since this is the difference between two points in world coordinates, the result is a vector in world coordinates as well.</p>
<p>To compute <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> (transformation of <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>), we will use <span class="math notranslate nohighlight">\(\mathbf{j}\)</span>, the unit vector we chose pointing upwards in local, world and camera spaces. This is because we typically limit the vertical rotation of the camera to less than <span class="math notranslate nohighlight">\(90°\)</span> around the x-axis (the reasons behind this will be explained in another tutorial). As a result, the angle between <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> will be less than <span class="math notranslate nohighlight">\(90°\)</span>. Similarly, the angle between <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> will be less than <span class="math notranslate nohighlight">\(180°\)</span>, as <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> must be orthogonal to each other.</p>
<figure class="align-default">
<img alt="../../../_images/view-matrix-rows.png" src="../../../_images/view-matrix-rows.png" />
</figure>
<p>Therefore, we can calculate <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> with the following cross product.</p>
<div class="math notranslate nohighlight">
\[\mathbf{f}=\displaystyle\frac{\mathbf{j}\times\mathbf{h}}{\vert\mathbf{j}\times\mathbf{h}\vert}\]</div>
<p>As explained above, the vector <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> remains consistent regardless the frame of reference (i.e., it has the same coordinates <span class="math notranslate nohighlight">\((0,1,0)\)</span> in both local and world spaces). Therefore, both <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> can be considered as expressed relative to the world space, which we defined as a left-handed system. This implies that the direction of <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> will be the one that sees <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> rotate clockwise towards <span class="math notranslate nohighlight">\(\mathbf{h}\)</span>, making <span class="math notranslate nohighlight">\(\mathbf{f}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> a left-handed system. This is exactly the expected result when transitioning from world space to view space, as we usually don’t want to change the handedness of the system we are working with after a transformation.</p>
<p>Finally, to compute <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> (transformation of <span class="math notranslate nohighlight">\(\mathbf{j}\)</span>), we can simply calculate the cross product between <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{f}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{g}=\mathbf{h}\times\mathbf{f}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> are unit vectors, so we don’t need to normalize the result. Recall what we stated in <a class="reference internal" href="vectors.html"><span class="std std-doc">Vectors</span></a>: the length of the vector resulting from the cross product <span class="math notranslate nohighlight">\(\mathbf{u}\times\mathbf{v}\)</span> is <span class="math notranslate nohighlight">\(\vert\mathbf{u}\times\mathbf{v}\vert=\vert\mathbf{u}\vert\vert\mathbf{v}\vert\sin{\theta}\)</span>. In this case, we have <span class="math notranslate nohighlight">\(\vert\mathbf{h}\vert=\vert\mathbf{f}\vert=1\)</span> and <span class="math notranslate nohighlight">\(\sin{90°}=1\)</span>.</p>
</div>
<p>DirectXMath provides the helper function <strong>XMMatrixLookAtLH</strong> to build a view matrix similar to the one we discussed in this section (i.e., for transitioning from world to camera spaces defined as left-handed systems). You need to pass the camera position and target point as arguments to this function, which returns the related view matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// pos: position (in world coordinates) of the (origin of the) view space.</span>
<span class="c1">// target: position (in world coordinates) where we want the camera is aimed at.</span>
<span class="c1">// up == j (unit basis vector which points up).</span>
<span class="n">XMVECTOR</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVectorSet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">XMVECTOR</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVectorZero</span><span class="p">();</span>
<span class="n">XMVECTOR</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVectorSet</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w"> </span>

<span class="c1">// Compute the View matrix.</span>
<span class="n">XMMATRIX</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMMatrixLookAtLH</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">up</span><span class="p">);</span>
</pre></div>
</div>
<br>
<p><strong>XMVectorSet</strong> and <strong>XMVectorZero</strong> are also helper functions. They allow us to initialize an <strong>XMVECTOR</strong> variable using a single SIMD instruction (if SIMD instructions are supported by the CPU).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As explained in <a class="reference internal" href="vectors.html"><span class="std std-doc">Vectors</span></a>, <strong>XMVECTOR</strong> is an alias for <strong>__m128</strong>, so we should avoid initializing it with a simple assignment or the usual array initialization, because these methods may require multiple instructions, which is inefficient. Instead, <strong>XMVectorSet</strong> and <strong>XMVectorZero</strong> offer a dual implementation (No-Intrinsics and SSE-Intrinsics, as detailed in <a class="reference internal" href="transformations.html"><span class="std std-doc">Transformations</span></a>) that allows the CPU to leverage SIMD instructions (if supported) to load four values into a 16-byte aligned <strong>__m128</strong> variable in a single instruction, significantly improving performance.</p>
</div>
<p>The implementation of the <strong>XMMatrixLookAtLH</strong> function should be relatively straightforward to understand, given the concepts we have discussed in this section and in <a class="reference internal" href="transformations.html"><span class="std std-doc">Transformations</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="n">XMMATRIX</span><span class="w"> </span><span class="n">XM_CALLCONV</span><span class="w"> </span><span class="n">XMMatrixLookAtLH</span>
<span class="p">(</span>
<span class="w">    </span><span class="n">FXMVECTOR</span><span class="w"> </span><span class="n">EyePosition</span><span class="p">,</span>
<span class="w">    </span><span class="n">FXMVECTOR</span><span class="w"> </span><span class="n">FocusPosition</span><span class="p">,</span>
<span class="w">    </span><span class="n">FXMVECTOR</span><span class="w"> </span><span class="n">UpDirection</span>
<span class="p">)</span><span class="w"> </span><span class="k">noexcept</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">EyeDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVectorSubtract</span><span class="p">(</span><span class="n">FocusPosition</span><span class="p">,</span><span class="w"> </span><span class="n">EyePosition</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">XMMatrixLookToLH</span><span class="p">(</span><span class="n">EyePosition</span><span class="p">,</span><span class="w"> </span><span class="n">EyeDirection</span><span class="p">,</span><span class="w"> </span><span class="n">UpDirection</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="n">XMMATRIX</span><span class="w"> </span><span class="n">XM_CALLCONV</span><span class="w"> </span><span class="n">XMMatrixLookToLH</span>
<span class="p">(</span>
<span class="w">    </span><span class="n">FXMVECTOR</span><span class="w"> </span><span class="n">EyePosition</span><span class="p">,</span>
<span class="w">    </span><span class="n">FXMVECTOR</span><span class="w"> </span><span class="n">EyeDirection</span><span class="p">,</span>
<span class="w">    </span><span class="n">FXMVECTOR</span><span class="w"> </span><span class="n">UpDirection</span>
<span class="p">)</span><span class="w"> </span><span class="k">noexcept</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">XMVector3Equal</span><span class="p">(</span><span class="n">EyeDirection</span><span class="p">,</span><span class="w"> </span><span class="n">XMVectorZero</span><span class="p">()));</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">XMVector3IsInfinite</span><span class="p">(</span><span class="n">EyeDirection</span><span class="p">));</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">XMVector3Equal</span><span class="p">(</span><span class="n">UpDirection</span><span class="p">,</span><span class="w"> </span><span class="n">XMVectorZero</span><span class="p">()));</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">XMVector3IsInfinite</span><span class="p">(</span><span class="n">UpDirection</span><span class="p">));</span>

<span class="w">    </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">R2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVector3Normalize</span><span class="p">(</span><span class="n">EyeDirection</span><span class="p">);</span>

<span class="w">    </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">R0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVector3Cross</span><span class="p">(</span><span class="n">UpDirection</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="p">);</span>
<span class="w">    </span><span class="n">R0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVector3Normalize</span><span class="p">(</span><span class="n">R0</span><span class="p">);</span>

<span class="w">    </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">R1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVector3Cross</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="n">R0</span><span class="p">);</span>

<span class="w">    </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">NegEyePosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVectorNegate</span><span class="p">(</span><span class="n">EyePosition</span><span class="p">);</span>

<span class="w">    </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">D0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVector3Dot</span><span class="p">(</span><span class="n">R0</span><span class="p">,</span><span class="w"> </span><span class="n">NegEyePosition</span><span class="p">);</span>
<span class="w">    </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">D1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVector3Dot</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">NegEyePosition</span><span class="p">);</span>
<span class="w">    </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">D2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVector3Dot</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="n">NegEyePosition</span><span class="p">);</span>

<span class="w">    </span><span class="n">XMMATRIX</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVectorSelect</span><span class="p">(</span><span class="n">D0</span><span class="p">,</span><span class="w"> </span><span class="n">R0</span><span class="p">,</span><span class="w"> </span><span class="n">g_XMSelect1110</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVectorSelect</span><span class="p">(</span><span class="n">D1</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">g_XMSelect1110</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMVectorSelect</span><span class="p">(</span><span class="n">D2</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="n">g_XMSelect1110</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="n">M</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_XMIdentityR3</span><span class="p">.</span><span class="n">v</span><span class="p">;</span>

<span class="w">    </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XMMatrixTranspose</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>EyePosition</strong>, <strong>FocusPosition</strong> and <strong>UpDirection</strong> are the origin, target and up direction of the camera, expressed in world coordinates.</p>
<br>
</section>
<section id="ndc-space-and-projection-matrix">
<span id="spaces-ndc-proj-label"></span><h2>NDC space and Projection matrix<a class="headerlink" href="#ndc-space-and-projection-matrix" title="Link to this heading">#</a></h2>
<p>Once we have all objects in camera space, the next step is to project them onto a plane to obtain a 2D representation of the 3D scene. To achieve this, we can ideally place a plane in front of the camera and trace rays from the camera to each vertex of the mesh, as illustrated in the image below. The intersection between these rays and the plane gives us a 2D representation of the corresponding 3D vertices. Note that if the projection rays are parallel to each other and orthogonal to the projection plane, the camera’s position becomes irrelevant.</p>
<figure class="align-default">
<img alt="../../../_images/projection.png" src="../../../_images/projection.png" />
</figure>
<p>In the first case, where the projection rays converge towards a focal point, distant objects appear smaller. This replicates the way human vision works in real life and we commonly refer to this type of projection as perspective.</p>
<p>On the other hand, if the projection rays are parallel to each other, the perspective effect is lost, and the size of objects becomes independent of their distance from the camera. This type of projection is known as orthographic.</p>
<p>To better understand the difference, consider the illustration provided below. It depicts two segments of equal size placed at different distances from the camera. In the perspective projection, the closer segment appears longer when projected onto the projection plane, emphasizing the depth perception effect.</p>
<figure class="align-default">
<img alt="../../../_images/projection2.png" src="../../../_images/projection2.png" />
</figure>
<p>Fortunately, the intricacies of the projection process are almost transparent to the programmer, who is primarily responsible for defining the portion of the 3D scene to be projected onto the projection plane. Indeed, in most cases, capturing the entire scene is not necessary or desired. Depending on the type of projection being used, different bounding geometries define the region of interest.</p>
<p>In orthographic projections, the region of interest is represented by a box. This box encompasses the portion of the scene that will be projected onto the 2D plane. While we can use any plane in front of the camera as the projection plane, typically the box face closest to the camera is used as the projection window where the 3D scene is projected.</p>
<p>In perspective projections, the region of interest is defined by a frustum. A frustum is the volume enclosed between two parallel planes that intersect a pyramid. The apex of the pyramid corresponds to the camera’s position. The plane closer to the camera is called the near plane, while the farther plane is called the far plane. We can obtain a projection window by intersecting the pyramid between the camera and the near plane, with another plane parallel to the near one. Alternatively, the upper face of the frustum, the intersection between the near plane and the pyramid, can also be used as the projection window. In computer graphics literature, the terms “near plane” and “far plane” are commonly used to refer to the corresponding windows as well.</p>
<figure class="align-default">
<img alt="../../../_images/frustum.png" src="../../../_images/frustum.png" />
</figure>
<p>The illustration below clearly demonstrates the differences between perspective and orthographic projections. In both projections, the green ball lies outside the defined region of interest and therefore is not projected onto the projection window.</p>
<p>In the orthographic projection, the red and yellow balls appear the same size, regardless of their distance from the camera. This is because the projection rays are parallel and do not converge towards a focal point, resulting in a lack of perspective distortion.</p>
<p>On the other hand, in the perspective projection, the red ball appears smaller compared to the yellow ball. This is due to the converging projection rays that mimic the behavior of human vision in real life. As objects move further away from the camera, they appear smaller, resulting in the size difference observed in the perspective projection.</p>
<figure class="align-default">
<img alt="../../../_images/persp-ortho.png" src="../../../_images/persp-ortho.png" />
</figure>
<p>To define a frustum (for perspective projections) or a box (for orthographic projections), we need to specify the distances from the camera to the near and far planes. For convenience, we typically define this bounding geometry in view space, where the camera position is located at the origin. Additionally, we need to determine the dimensions of the projection window. With this information, we can construct a projection matrix. This matrix transforms 3D vertices from view space to a space called Normalized Device Coordinates (NDC).</p>
<p>In perspective projection, the frustum defined in view space becomes a box in NDC space. The origin of this box is located at the center of its front face, which corresponds to the transformed near plane\window. A significant aspect of interest is that the objects contained within the box in NDC space (previously within the frustum\box in view space) will have vertex coordinates falling within the following ranges:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
-1\le x\le 1 \\ 
\\
-1\le y\le 1 \\
\\
0\le z\le 1
\end{align*}
\end{split}\]</div>
<p>The illustration below depicts the frustum in view space (left) and the corresponding box in NDC space (right) after a perspective transformation. In DirectX, the NDC space is a left-handed system, with the y-axis that points upwards. The z-axis is always perpendicular to both the front and back faces of the box in NDC space and passes through their centers. While this arrangement also holds in view space, it is not an absolute requirement. Indeed, the z-axis in view space can be non-perpendicular to both the near and far planes, and it may pass through a point other than their centers.</p>
<figure class="align-default">
<img alt="../../../_images/persp-ndc.png" src="../../../_images/persp-ndc.png" />
</figure>
<p>Now, you might be wondering what’s the point of this transformation. The following illustration shows a 2D representation from the top that explains what happens if you transform a frustum to a box. The objects inside the frustum are transformed accordingly, and the projection rays become parallel to each other. This way, we can orthographically project the mesh vertices onto a projection window (typically the front face of the box in NDC space) to mimic the perspective vision we are used to in real life, where objects like roads seem to converge in the distance, and where near objects appear bigger than distant ones.</p>
<figure class="align-default">
<img alt="../../../_images/persp-ndc2.png" src="../../../_images/persp-ndc2.png" />
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Interestingly, once we are in NDC space, there is no actual need for explicit projection onto the window plane. Indeed, as mentioned earlier, in NDC space the projection rays are parallel, and the z-axis is orthogonal to the front face of the NDC box, passing through its center (which is the origin of the NDC space). This means that the x- and y-coordinates of vertices remain constant along the projection rays in NDC space, only the z-coordinate varies. Consequently, the x- and y-coordinates of a vertex in NDC space are identical both inside the NDC box and when projected onto the front face (which lies in the <span class="math notranslate nohighlight">\(z=0\)</span> plane of the NDC space). The illustration below provides a top-down view that further demonstrates this concept. It shows that the x-coordinate of a vertex remains constant along the projection ray. The same applies to the y-coordinate if you look at the NDC space sideways.</p>
<figure class="align-default">
<img alt="../../../_images/ndc.png" src="../../../_images/ndc.png" />
</figure>
</div>
<p>Usually, that’s all we need to know in order to write applications that renders 3D objects on the screen using a perspective or orthographic effect. However, as graphics programmers, we are expected to know how things work under the hood. In particular, knowing how to build a projection matrix might come in useful in the future.</p>
<p>As stated in the note box above, once we go from view space to NDC space, we implicitly get a 2D representation of 3D vertex positions. So, this transformation is definitely related to the concept of projection. Indeed, the associated matrix is called projection matrix, that can vary depending on the type of projection we are interested in. We will start with a couple of matrices associated with the perspective projection, and then we will show the matrix associated with the orthographic projection.</p>
<section id="perspective-projection">
<h3>Perspective projection<a class="headerlink" href="#perspective-projection" title="Link to this heading">#</a></h3>
<p>While DirectX offers convenient helper functions for constructing projection matrices, in this section we will explore the process of manually creating a couple of projection matrices based on frustum information. Our first objective is to derive NDC coordinates from view coordinates. Then, we will attempt to express the resulting equations in matrix form, with the goal of finding a projection matrix to go from the view space to the NDC space. Consider the following illustration.</p>
<figure class="align-default" id="spaces-persp-proj">
<img alt="../../../_images/persp-proj.png" src="../../../_images/persp-proj.png" />
<figcaption>
<p><span class="caption-number">Fig. 14 </span><span class="caption-text">Frustum in view space</span><a class="headerlink" href="#spaces-persp-proj" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>To construct a projection matrix, we must first define a frustum (in view space) that provides the necessary information. Regarding the projection window, as explained in <a class="reference internal" href="#spaces-ndc-proj-label"><span class="std std-ref">NDC space and Projection matrix</span></a>, we can opt for the intersection between the pyramid formed by the camera and the near plane, with any plane parallel to the near one. For our purposes, let’s conveniently choose a plane at a distance <span class="math notranslate nohighlight">\(d\)</span> along the z-axis from the camera (located at the origin <span class="math notranslate nohighlight">\(\mathbf{O}_v\)</span> of the view space) so that the height of the projection window is <span class="math notranslate nohighlight">\(2\)</span>.</p>
<p>The angle <span class="math notranslate nohighlight">\(\theta\)</span>, known as the vertical FOV (field of view), allows us to control the vertical extent of the visible scene in view space. Notably, by setting <span class="math notranslate nohighlight">\(\theta\)</span> as the angle between the top and bottom sides of the frustum, we implicitly establish the distance <span class="math notranslate nohighlight">\(d\)</span>, given our earlier requirement that the height of the projection window be <span class="math notranslate nohighlight">\(2\)</span>. On the other hand, the angle <span class="math notranslate nohighlight">\(\phi\)</span> controls the horizontal FOV. This means we can zoom-in by simply decreasing <span class="math notranslate nohighlight">\(\theta\)</span> and\or <span class="math notranslate nohighlight">\(\phi\)</span>, as this reduces the visible region, which results in fewer objects being projected onto the projection window. Conversely, if we increase <span class="math notranslate nohighlight">\(\theta\)</span> and\or <span class="math notranslate nohighlight">\(\phi\)</span> we have a zoom-out effect because more objects are projected onto the projection window.</p>
<p>However, the horizontal FOV <span class="math notranslate nohighlight">\(\phi\)</span> is not typically used directly to control the width of the projection window. Instead, we set the aspect ratio <span class="math notranslate nohighlight">\(r\)</span> of the window. This approach is crucial to prevent distortion when mapping the projection window onto the render target, which ultimately gets mapped to the window’s client area. Hence, we define <span class="math notranslate nohighlight">\(r=w/h=w/2\)</span>, where <span class="math notranslate nohighlight">\(w\)</span> and <span class="math notranslate nohighlight">\(h\)</span> represent the width and length of the render target, respectively. Consequently, the width of the projection window is <span class="math notranslate nohighlight">\(w=2r\)</span>. As depicted in the illustration above, the horizontal FOV <span class="math notranslate nohighlight">\(\phi\)</span> is dependent on both the aspect ratio <span class="math notranslate nohighlight">\(r\)</span> and the distance <span class="math notranslate nohighlight">\(d\)</span> of the projection window (which, in turn, depends on the vertical FOV <span class="math notranslate nohighlight">\(\theta\)</span>).</p>
<p>Observe that the z-axis is orthogonal to the projection window and passes through its center, dividing the height of the projection window into two parts of unit lengths. Also, the near and far planes are located at a distance of <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(f\)</span> units from the camera. This represents the most commonly used form of frustum, although it is just a specific case. We will explore a more general case later in this section.</p>
<p>Since the z-axis is orthogonal to the projection window and passes through its center, any 3D vertex projected onto its surface will have the y-coordinate already in NDC space (i.e., within the range <span class="math notranslate nohighlight">\([-1, 1]\)</span>). You can verify it in the illustration above, where the perspective projection <span class="math notranslate nohighlight">\(y_w\)</span> of the y-coordinate <span class="math notranslate nohighlight">\(y_v\)</span> of a 3D vertex in view space is always within the range <span class="math notranslate nohighlight">\([-1, 1]\)</span>. On the other hand, the perspective projection <span class="math notranslate nohighlight">\(x_w\)</span> of the x-coordinate <span class="math notranslate nohighlight">\(x_v\)</span> of the same vertex in view space needs to be scaled by <span class="math notranslate nohighlight">\(1/r\)</span> to fit within the same range. As for the z-coordinate, it requires a separate discussion, which we will delve into shortly.</p>
<figure class="align-default">
<img alt="../../../_images/persp-proj2.png" src="../../../_images/persp-proj2.png" />
</figure>
<p>Let’s start by examining <span class="math notranslate nohighlight">\(y_w\)</span>, which represents the perspective projection of the y-coordinate of a 3D vertex <span class="math notranslate nohighlight">\(\mathbf{v}_v=(x_v, y_v, z_v, w_v)\)</span> in view coordinates. The projection window lies in the plane <span class="math notranslate nohighlight">\(z=d\)</span>. As mentioned at the begin of the section, we want to find a formula to derive NDC coordinates from view coordinates. To achieve this, let’s consider the triangles <span class="math notranslate nohighlight">\(\triangle_1=(\mathbf{O}_v, d, y_w)\)</span> and <span class="math notranslate nohighlight">\(\triangle_2=(\mathbf{O}_v, z_v, y_v)\)</span>. These triangles are similar because they share an angle (the one at <span class="math notranslate nohighlight">\(\mathbf{O}_v\)</span>), and both have a right angle. So, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\frac{y_w}{d}&amp;=\frac{y_v}{z_v} \\ 
\\
y_{ndc} &amp;= y_w = \frac{dy_v}{z_v}\quad\quad\quad\quad\tag{1}\label{eq:ASpaces1}
\end{align}
\end{split}\]</div>
<p>Also, we know that <span class="math notranslate nohighlight">\(d\)</span> depends on the vertical FOV <span class="math notranslate nohighlight">\(\theta\)</span>. Indeed, you can check from image <a class="reference internal" href="#spaces-persp-proj"><span class="std std-numref">Fig. 14</span></a> that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\frac{1}{d}&amp;=\tan{\left({\frac{\theta}{2}}\right)} \\ 
\\
d&amp;=\frac{1}{\tan{(\theta/2)}}=\cot{\left(\frac{\theta}{2}\right)}\quad\quad\quad\quad\tag{1b}\label{eq:ASpaces1b}
\end{align*}
\end{split}\]</div>
<p>If you want to compute the horizontal FOV <span class="math notranslate nohighlight">\(\phi\)</span>, we have that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
tan{(\phi/2)}&amp;=r/d=r/cot{(\theta/2)}=r\ tan{(\theta/2)} \\ 
\\
\phi&amp;=2\ {tan}^{-1}{(r\ tan{(\theta/2)})}\quad\quad\quad\quad\tag{1c}\label{eq:ASpaces1c}
\end{align*}
\end{split}\]</div>
<p>As for <span class="math notranslate nohighlight">\(x_w\)</span>, we have a similar calculation. However, we need to consider the width of the projection window and the final scaling by <span class="math notranslate nohighlight">\(1/r\)</span> to derive the related NDC coordinate.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\frac{x_w}{d}&amp;=\frac{x_v}{z_v} \\ 
\\
x_w&amp;=\frac{dx_v}{z_v} \\
\\
x_{ndc}&amp;=\frac{x_w}{r}=\frac{dx_v}{rz_v}\quad\quad\quad\quad\tag{2}\label{eq:ASpaces2}
\end{align*}
\end{split}\]</div>
<p>Observe that a vertex in view space <span class="math notranslate nohighlight">\(\mathbf{v}_v=(x_v, y_v, z_v, w_v)\)</span> is inside the frustum if and only if</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
-r\ \le\ x_w\ \le\ r \\ 
\\
-1\ \le\ y_w\ \le\ 1 \\
\\
n\ \le\ z_v\ \le\ f
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(x_w\)</span> and <span class="math notranslate nohighlight">\(y_w\)</span> are the first two coordinates of the projection of <span class="math notranslate nohighlight">\(\mathbf{v}_v\)</span> onto the projection window. As for the other two NDC coordinates, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
z_{ndc}&amp;=z_{ndc}\quad\quad\quad\quad\tag{3}\label{eq:ASpaces3} \\ 
\\
w_{ndc}&amp;=w_v=1\quad\quad\quad\quad\tag{4}\label{eq:ASpaces4}
\end{align*}
\end{split}\]</div>
<p>As we know, a vertex position is a point, so the w-coordinate is always 1 regardless of the coordinate space. As for <span class="math notranslate nohighlight">\(z_{ndc}\)</span>, there are additional considerations to take into account before deriving this NDC coordinate from the view one, so we will temporarily write a dummy <span class="math notranslate nohighlight">\(z_{ndc}=z_{ndc}\)</span>.</p>
<p>However, before deriving <span class="math notranslate nohighlight">\(z_{ndc}\)</span> from <span class="math notranslate nohighlight">\(z_v\)</span>, we can draw our first, unfortunate, conclusion: we cannot express in matrix form the transformation from view space to NDC space using equations <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces1}\)</span> through <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces4}\)</span>. The reason is that a matrix form can be used if we have a linear combination of the rows of the matrix with the components of the vector as coefficients, as explained in <a class="reference internal" href="matrices.html"><span class="std std-doc">Matrices</span></a> and <a class="reference internal" href="transformations.html"><span class="std std-doc">Transformations</span></a>. The presence of the <span class="math notranslate nohighlight">\(z_v\)</span> term in the denominator of <span class="math notranslate nohighlight">\(x_{ndc}\)</span> and <span class="math notranslate nohighlight">\(y_{ndc}\)</span> (equations <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces1}\)</span> and <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces2}\)</span>) prevents us from directly representing the transformation as a matrix multiplication. Indeed, there’s no way to multiply a vector by a matrix and have a vector component appearing in the denominator of any coefficient within the linear combination of the matrix’s rows. So, we need to come up with something else to get a matrix form anyway.</p>
<p>Observe that if we multiply the NDC coordinates by <span class="math notranslate nohighlight">\(z_v\)</span> (equations <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces1}\)</span> through <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces4}\)</span>) we can derive a matrix form to transform a vertex from view space to a temporary space that is similar to NDC space, except for a division by <span class="math notranslate nohighlight">\(z_v\)</span>. The trick is to place <span class="math notranslate nohighlight">\(z_v\)</span> in the w-component of the temporary coordinates and let the rasterizer perform the division by <span class="math notranslate nohighlight">\(z_v\)</span> for us. This operation is called perspective division because it is related to the perspective projection. Observe that we are using the last coordinate to hold a value that divides the other components, so this temporary space is an homogeneous space, as explained in <a class="reference internal" href="vectors.html"><span class="std std-doc">Vectors</span></a>. This homogeneous space is usually referred to as clip space (and its coordinates as clip coordinates) because it is a convenient space for discarding primitives outside the frustum and clipping primitives that intersect the frustum’s boundary (more on this shortly). Well, it turns out that clip coordinates are exactly what the rasterizer expects before performing perspective division, so we can use this trick to find a matrix form that transforms view coordinates into clip coordinates.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The rasterizer expects to receive primitives with vertices in clip coordinates as input. Therefore, the last stage before the rasterizer must output vertices in clip space. Typically, if no optional stage is enabled, the last stage before the rasterizer is the vertex shader. Otherwise, it can be one between geometry shader and domain shader.</p>
</div>
<p>With the perspective division automatically performed by the rasterizer, we are able to transform the coordinates of a vertex from clip to NDC space. Now, we need to find a matrix form to go from view space to clip space. To do this, we must first multiply equations equations <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces1}\)</span> through <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces4}\)</span> by <span class="math notranslate nohighlight">\(z_v\)</span> to obtain the clip coordinates <span class="math notranslate nohighlight">\(\mathbf{v}_c\)</span>, that represents the vertex in clip space.</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
x_c&amp;=\frac{d\ x_v}{r} \cr \cr
y_c&amp;=d\ y_v \cr \cr
z_c&amp;=z_{ndc}\ z_v \cr \cr
w_c&amp;=z_v
\end{align*}
\]</div>
<p>Remember that we still need to derive <span class="math notranslate nohighlight">\(z_{ndc}\)</span> from the view coordinates of the vertex. Meanwhile, we can write the above equations in the following matrix form as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\mathbf{v}_c=\left\lbrack\matrix{x_v&amp;y_v&amp;z_v&amp;w_v}\right\rbrack\left\lbrack\matrix{d/r&amp;0&amp;0&amp;0\cr 0&amp;d&amp;0&amp;0\cr 0&amp;0&amp;z_ {ndc}&amp;1\cr 0&amp;0&amp;0&amp;0}\right\rbrack \quad\quad\quad\quad\tag{5}\label{eq:ASpaces5} \\
\end{align*}
\end{split}\]</div>
<p>Then, to get the NDC coordinates, we simply need to divide all the components of <span class="math notranslate nohighlight">\(\mathbf{v}_c\)</span> by <span class="math notranslate nohighlight">\(z_v\)</span> (operation automatically performed by the rasterizer; we will simply enjoy the result in the pixel shader).</p>
<p>We can now focus on deriving a formula for <span class="math notranslate nohighlight">\(z_{ndc}\)</span> starting from <span class="math notranslate nohighlight">\(z_v\)</span>. Actually, we simply need to re-map <span class="math notranslate nohighlight">\(z_v\)</span> from <span class="math notranslate nohighlight">\([n, f]\)</span> (the range defined by the near and far planes of the frustum in view space) to <span class="math notranslate nohighlight">\([0, 1]\)</span> (the range defined by front and back faces of the corresponding box in NDC space). That is, we want the normalized distance between the vertex and the projection window (front face of the NDC box).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As already mentioned several times in this section, we can intersect any plane with the pyramid between the camera and the near plane to obtain the projection window. The result represents the same projection window but at different distances from the camera. This difference in distance does not affect the x- and y-coordinates, as previously explained. However, it does impact the z-coordinate, which requires to be handled separately, as discussed in the current explanation.</p>
</div>
<p>Observe that <span class="math notranslate nohighlight">\(n\)</span> in view space is mapped to <span class="math notranslate nohighlight">\(0\)</span> in NDC space, while <span class="math notranslate nohighlight">\(f\)</span> is mapped to <span class="math notranslate nohighlight">\(1\)</span>. Therefore, we need a scaling <span class="math notranslate nohighlight">\(S\)</span> to resize the range <span class="math notranslate nohighlight">\([n, f]\)</span> from <span class="math notranslate nohighlight">\((f-n)\)</span> to <span class="math notranslate nohighlight">\(1\)</span> (the size of the range <span class="math notranslate nohighlight">\([0, 1]\)</span>), plus a translation <span class="math notranslate nohighlight">\(T\)</span> to shift the scaled range so that it covers exactly the values in <span class="math notranslate nohighlight">\([0, 1]\)</span>. Therefore, the generic equation is</p>
<div class="math notranslate nohighlight">
\[z_c=Sz_v+T\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The equation above uses <span class="math notranslate nohighlight">\(z_c\)</span> (instead of <span class="math notranslate nohighlight">\(z_{ndc}\)</span>) to denote a clip coordinate. This is because the matrix in equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces5}\)</span> transforms from view space to clip space, not directly to NDC space. However, this does not alter the observations made above: we still require a scaling operation followed by a translation to resize and remap the range of the z-coordinate, even in clip space. Indeed, the difference between clip and NDC coordinates can be seen a straightforward, additional scaling operation.</p>
</div>
<p>Consequently, the matrix in equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces5}\)</span> becomes</p>
<div class="math notranslate nohighlight">
\[\left\lbrack\matrix{d/r&amp;0&amp;0&amp;0\cr 0&amp;d&amp;0&amp;0\cr 0&amp;0&amp;S&amp;1\cr 0&amp;0&amp;T&amp;0}\right\rbrack \tag{6}\label{eq:ASpaces6}\]</div>
<p>because the last two entry in the third column are the only ones that can scale and translate the third coordinate of <span class="math notranslate nohighlight">\(\mathbf{v}_v\)</span>, that is <span class="math notranslate nohighlight">\(z_v\)</span>. To find <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span>, we can multiply the matrix above by a couple of vertices in view space which we already know the results in NDC space. For example, we know that for a vertex in view space that lies in the near plane we have <span class="math notranslate nohighlight">\(z_{ndc}=0\)</span> (since <span class="math notranslate nohighlight">\(z_v=n\)</span>, and we know that <span class="math notranslate nohighlight">\(n\)</span> maps to <span class="math notranslate nohighlight">\(0\)</span>). So, if we multiply the vertex <span class="math notranslate nohighlight">\(\mathbf{v}_v=(0, 0, n, 1)\)</span> (which lies in the near plane) by the matrix <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces6}\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}_c=\left\lbrack\matrix{0&amp;0&amp;n&amp;1}\right\rbrack\left\lbrack\matrix{d/r&amp;0&amp;0&amp;0\cr 0&amp;d&amp;0&amp;0\cr 0&amp;0&amp;S&amp;1\cr 0&amp;0&amp;T&amp;0}\right\rbrack=\left\lbrack\matrix{0\cr 0\cr Sn+T\cr n}\right\rbrack^T\]</div>
<p>The coordinates of <span class="math notranslate nohighlight">\(\mathbf{v}_c\)</span> are in clip space, and after the perspective division (by <span class="math notranslate nohighlight">\(w_c=n\)</span>) we have</p>
<div class="math notranslate nohighlight">
\[\displaystyle z_{ndc}=S+\frac{T}{n}\]</div>
<p>However, in this case we know that <span class="math notranslate nohighlight">\(z_{ndc}=0\)</span>, so we have that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
0&amp;=S+\frac{T}{n} \\
\\
T&amp;=-Sn\quad\quad\quad\quad\tag{7}\label{eq:ASpaces7}
\end{align*}
\end{split}\]</div>
<p>We also know that for a vertex in view space that lies in the far plane we have <span class="math notranslate nohighlight">\(z_{ndc}=1\)</span> (since <span class="math notranslate nohighlight">\(z_v=f\)</span>, and we know that <span class="math notranslate nohighlight">\(f\)</span> maps to <span class="math notranslate nohighlight">\(1\)</span>). Therefore, if we multiply the vertex <span class="math notranslate nohighlight">\(\mathbf{v}_v=(0,0,f,1)\)</span> (which lies in the far plane) by the matrix <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces6}\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}_c=\left\lbrack\matrix{0&amp;0&amp;f&amp;1}\right\rbrack\left\lbrack\matrix{d/r&amp;0&amp;0&amp;0\cr 0&amp;d&amp;0&amp;0\cr 0&amp;0&amp;S&amp;1\cr 0&amp;0&amp;-Sn&amp;0}\right\rbrack=\left\lbrack\matrix{0\cr 0\cr Sf-Sn\cr f}\right\rbrack^T\]</div>
<p>where we used <span class="math notranslate nohighlight">\(T=-Sn\)</span>. After the perspective division (by <span class="math notranslate nohighlight">\(w_c=f\)</span>) we have</p>
<div class="math notranslate nohighlight">
\[\displaystyle z_{ndc}=S-S\ \frac{n}{f}=S\left(1-\frac{n}{f}\right)\]</div>
<p>However, in this case we know that <span class="math notranslate nohighlight">\(z_{ndc}=1\)</span> so,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
1&amp;=S\left(1-\frac{n}{f}\right) \\
\\
S&amp;=\frac{1}{1-\displaystyle\frac{n}{f}}=\frac{1}{\displaystyle\frac{f-n}{f}}=\frac{f}{f-n}
\end{align*}
\end{split}\]</div>
<p>Substituting this into equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces7}\)</span> we have</p>
<div class="math notranslate nohighlight">
\[ T=-\left(\frac{f}{f-n}\right)n=-\frac{fn}{f-n} \]</div>
<p>We just found the values of <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span>, so that we can write the z-coordinate both in clip space and in NDC space, after the perspective division, as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\displaystyle z_c&amp;=\frac{f}{f-n}z_v-\frac{nf}{(f-n)}\quad\quad\quad\quad\tag{8}\label{eq:ASpaces8} \\
\\
\displaystyle z_{ndc}&amp;=\frac{f}{f-n}-\frac{nf}{(f-n)z_v}\quad\quad\quad\quad\tag{9}\label{eq:ASpaces9}
\end{align*}
\end{split}\]</div>
<p>Matrix <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces6}\)</span> now only depends on the distances of the near and far planes from the camera. This means that we can build this matrix by only using the frustum information at our disposal as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{P}=\left\lbrack\matrix{d/r\ &amp;0&amp;0&amp;0\cr 0&amp;d&amp;0&amp;0\cr 0&amp;0&amp;\frac{f}{f-n}&amp;1\cr 0&amp;0&amp;-\frac{nf}{f-n}&amp;0}\right\rbrack \tag{10}\label{eq:ASpaces10}\]</div>
<p>Matrix <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces10}\)</span> can be used to transform vertex positions from view space to homogeneous clip space.</p>
<p>Although, that’s not what we wanted to find at the start of this section (the matrix to go from view to NDC space). However, since we get the perspective division for free during the rasterizer stage, we can actually consider <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> as the perspective projection matrix to go from the view space to NDC space.</p>
<section id="general-case">
<h4>General case<a class="headerlink" href="#general-case" title="Link to this heading">#</a></h4>
<p>We built the perspective projection matrix <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces10}\)</span> with the assumption that the z-axis goes through the center of the projection window. However, in a more general case, we have a scenario similar to the one shown in the illustration below.</p>
<figure class="align-default">
<img alt="../../../_images/persp-proj3.png" src="../../../_images/persp-proj3.png" />
</figure>
<p>Deriving a perspective projection matrix for the general case won’t be overly difficult given our exploration of the specific case in the previuos section. Indeed, after projecting the 3D vertices onto the projection window, we need to translate the projection window so that the z-axis goes through its center again, bringing us back to the specific case. However, before proceeding, some initial observations are necessary.</p>
<ul class="simple">
<li><p>In the general case, the frustum is not necessarily symmetrical with respect to the z-axis, so we can’t use the vertical FOV and aspect ratio to define the size of the projection window. Instead, we need to set its width and height by specifying the view coordinates of its top, bottom, left, and right sides.</p></li>
<li><p>We will project 3D vertices onto the projection window that lies on the near plane (meaning <span class="math notranslate nohighlight">\(d=n\)</span>). This isn’t really a limitation because we can project onto any projection window between the camera (exclusive) and near plane (inclusive).</p></li>
</ul>
<p>Thus, in the general case, a vertex <span class="math notranslate nohighlight">\(\mathbf{v}_v=(x_v, y_v, z_v)\)</span> in view space is inside the frustum if and only if</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
l\ \le\ x_w\ \le\ r \\
\\
b\ \le\ y_w\ \le\ t \\
\\
n\ \le\ z_v\ \le\ f
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(r, l, t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are the view coordinates of the right, left, top and bottom sides of the projection window that lies on the near plane.</p>
<p>Therefore, we need to translate the first two coordinates of <span class="math notranslate nohighlight">\(\mathbf{v}_w\)</span> (projection of <span class="math notranslate nohighlight">\(\mathbf{v}_v\)</span>) so that the z-axis passes through the center of the projection window.  As mentioned earlier, this brings the problem back to the specific case we have already examined.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
x_w&amp;=x_w-\frac{r+l}{2} \quad\quad\quad\quad\tag{11}\label{eq:ASpaces11} \\
\\
y_w&amp;=y_w-\frac{t+b}{2} \quad\quad\quad\quad\tag{12}\label{eq:ASpaces12}
\end{align*}
\end{split}\]</div>
<p>Observe that we used the mid-point formula to subtract the x- and y- center coordinates of the projection window from <span class="math notranslate nohighlight">\(x_w\)</span> and <span class="math notranslate nohighlight">\(y_w\)</span>, respectively. Now, to get the NDC coordinates, we need to scale their ranges. That is, since <span class="math notranslate nohighlight">\(x_w\)</span> is in the range <span class="math notranslate nohighlight">\([l, r]\)</span> and <span class="math notranslate nohighlight">\(y_w\)</span> is in the range <span class="math notranslate nohighlight">\([b,t]\)</span>, we must re-map both to the range <span class="math notranslate nohighlight">\([-1, 1]\)</span>. If we multiply <span class="math notranslate nohighlight">\(x_w\)</span> (as expressed in equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces11}\)</span>) by <span class="math notranslate nohighlight">\((t-b)^{-1}\)</span> and <span class="math notranslate nohighlight">\(y_w\)</span> (as expressed in equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces12}\)</span>) by <span class="math notranslate nohighlight">\((r-l)^{-1}\)</span>, then both ranges will be in <span class="math notranslate nohighlight">\([-0.5, 0.5]\)</span>. At that point, we only need to multiply by 2 to scale both ranges to <span class="math notranslate nohighlight">\([-1, 1]\)</span>. These transformations are reflected in the following equations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
x_{ndc}&amp;=\frac{2\ x_w}{r-l}-\frac{2(r+l)}{2(r-l)} \quad\quad\quad\quad\tag{13}\label{eq:ASpaces13} \\
\\
y_{ndc}&amp;=\frac{2\ y_w}{t-b}-\frac{2(t+b)}{2(t-b)} \quad\quad\quad\quad\tag{14}\label{eq:ASpaces14}
\end{align*}
\end{split}\]</div>
<p>Now that we are back to the specific case, we can substitute equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces1}\)</span> into equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces14}\)</span>, keeping in mind that we now have <span class="math notranslate nohighlight">\(d=n\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
y_{ndc}&amp;=\frac{2(ny_v/z_v)}{t-b}-\frac{2(t+b)}{2(t-b)} \\
\\
&amp;=\frac{2n(y_v/z_v)}{t-b}-\frac{(t+b)(z_v/z_v)}{(t-b)} \\
\\
&amp;=\frac{2ny_v}{t-b}\cdot\frac{1}{z_v}-\frac{z_v(t+b)}{(t-b)}\cdot\frac{1}{z_v} \\
\\
&amp;=\frac{1}{z_v}\left(\frac{2n}{t-b}y_v-\frac{t+b}{t-b}z_v\right)\quad\quad\quad\quad\tag{15}\label{eq:ASpaces15}
\end{align*}
\end{split}\]</div>
<p>Similarly, we can substitute equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces2}\)</span> (in particular, the second one of the three equations) into equation <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces13}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
x_{ndc}&amp;=\frac{2(nx_v/z_v)}{r-l}-\frac{2(r+l)}{2(r-l)} \\
\\
&amp;=\frac{2n(x_v/z_v)}{r-l}-\frac{(r+l)(z_v/z_v)}{(r-l)} \\
\\
&amp;=\frac{2nx_v}{r-l}\cdot\frac{1}{z_v}-\frac{z_v(r+l)}{(r-l)}\cdot\frac{1}{z_v} \\
\\
&amp;=\frac{1}{z_v}\left(\frac{2n}{r-l}x_v-\frac{r+l}{r-l}z_v\right)\quad\quad\quad\quad\tag{16}\label{eq:ASpaces16}
\end{align*}
\end{split}\]</div>
<p>With equations <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces15}\)</span> and <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces16}\)</span>, we have found a way to calculate the first two NDC coordinates from the corresponding view coordinates. As for <span class="math notranslate nohighlight">\(z_{ndc}\)</span>, the equation remains unchanged from the one we derived in <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces8}\)</span> for the specific case because the solution still involves to map the range <span class="math notranslate nohighlight">\([n,f]\)</span> to <span class="math notranslate nohighlight">\([0,1]\)</span>.</p>
<p>If we omit the perspective division <span class="math notranslate nohighlight">\((1/z_v)\)</span> in <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces15}\)</span> and <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces16}\)</span>, we can express the clip coordinates as a linear combination of the view coordinates. This means the perspective projection matrix <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces10}\)</span> becomes</p>
<div class="math notranslate nohighlight">
\[\mathbf{P}=\left\lbrack\matrix{\frac{2n}{r-l}&amp;0&amp;0&amp;0\cr 0&amp;\frac{2n}{t-b}&amp;0&amp;0\cr -\frac{r+l}{r-l}&amp;-\frac{t+b}{t-b}&amp;\frac{f}{f-n}&amp;1\cr 0&amp;0&amp;-\frac{nf}{f-n}&amp;0}\right\rbrack \tag{17}\label{eq:ASpaces17}\]</div>
</section>
<section id="perspective-division-and-clipping">
<h4>Perspective division and clipping<a class="headerlink" href="#perspective-division-and-clipping" title="Link to this heading">#</a></h4>
<p>After the perspective division by the w-component, the vertices inside the NDC box are the ones with NDC coordinates falling within the following ranges</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
-1\le x/w\le 1 \\ 
\\
-1\le y/w\le 1 \\
\\
0\le z/w\le 1
\end{align*}
\end{split}\]</div>
<p>This means that the vertices inside the frustum were the ones with homogeneous coordinates falling within the following ranges</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
-w\le x\le w \\ 
\\
-w\le y\le w \\
\\
 0\le z\le w
\end{align*}
\end{split}\]</div>
<p>That is, the vertices inside the frustum are the ones bounded by the following homogeneous planes (that is, 4D planes expressed in clip coordinates).</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
\text{Left: }\quad  &amp;w = -x \\ 
\\
\text{Right: }\quad &amp;w = x \\
\\
\text{Bottom: }\quad  &amp;w = -y \\ 
\\
\text{Top: }\quad  &amp;w = y \\ 
\\
\text{Near: }\quad  &amp;w = 0 \\ 
\\
\text{Far: }\quad  &amp;w = z
\end{flalign}
\end{split}\]</div>
<p>The following illustration shows a 2D representation of the frustum in the homogeneous xw-plane.</p>
<figure class="align-default">
<img alt="../../../_images/persp-div.png" src="../../../_images/persp-div.png" />
</figure>
<p>If <span class="math notranslate nohighlight">\(w\ne 0\)</span>, we know that after the perspective division we always have <span class="math notranslate nohighlight">\(w=1\)</span>. In this 2D case, the perspective division is essentially a projection onto the line <span class="math notranslate nohighlight">\(w=1\)</span>. This means that a 2D object is projected to reduce its dimension to 1D. The same applies to objects in clip space: the perspective division projects object in a 4D space (the clip space) onto a 3D Cartesian space (the NDC space).</p>
<p>We have <span class="math notranslate nohighlight">\(w=0\)</span> if a vertex lies in the near plane. Indeed, in that case we have <span class="math notranslate nohighlight">\(w=z_v=0\)</span>, which is the value the rasterizer uses to divide the other coordinates. To avoid divide-by-zero exceptions, as well as processing objects outside the visible region for nothing, the rasterizer clips primitives intersecting the planes of the frustum before executing the perspective division. Clipping is automatically performed by the rasterizer, so we won’t cover the implementation of an efficient clipping algorithm here. However, typically, a rasterizer simply clips primitives intersecting the near plane before the perspective division (in clip space), and discard non-visible pixels after the perspective division.</p>
<figure class="align-default">
<img alt="../../../_images/clipping.png" src="../../../_images/clipping.png" />
</figure>
<p>As you can see in the image above, a clipped primitive might no longer be a triangle. Therefore, the rasterizer also needs to triangulate clipped primitives, and re-inserts them in the pipeline.</p>
</section>
<section id="depth-buffer-precision">
<h4>Depth buffer precision<a class="headerlink" href="#depth-buffer-precision" title="Link to this heading">#</a></h4>
<p>Whatever perspective projection matrix you decide to use (either <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces10}\)</span> or <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces17}\)</span>), after the perspective division we have</p>
<div class="math notranslate nohighlight">
\[\displaystyle z_{ndc}=\frac{f}{f-n}-\frac{nf}{(f-n)z_v}\]</div>
<p>If you set <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(f\)</span>, this equation  represents a strictly increasing function of <span class="math notranslate nohighlight">\(z_v\)</span>, with <span class="math notranslate nohighlight">\(z_v=1\)</span> acting as a horizontal asymptote. Mathematically, this implies that for every <span class="math notranslate nohighlight">\(z_v\)</span> value, there exists a unique corresponding <span class="math notranslate nohighlight">\(z_{ndc}\)</span>. However, when working with computers, this property cannot be relied upon due to the finite precision of floating-point representations. Moreover, the density of representable floating-point values is higher near zero and decreases as values move further away.</p>
<p>The following graph shows what happens if you set <span class="math notranslate nohighlight">\(n=1\)</span> and <span class="math notranslate nohighlight">\(f=100\)</span>. Approximately <span class="math notranslate nohighlight">\(80%\)</span> of the NDC values in the range <span class="math notranslate nohighlight">\([0, 1]\)</span> are available for less than <span class="math notranslate nohighlight">\(5%\)</span> of the view values in the range <span class="math notranslate nohighlight">\([n,f]\)</span>. Consequently, the remaining <span class="math notranslate nohighlight">\(95%\)</span> of the view values must share the remaining <span class="math notranslate nohighlight">\(20%\)</span> of the NDC values. As a result, it is likely that different view values close to <span class="math notranslate nohighlight">\(100\)</span> cannot be represented by unique NDC values. In other words, different <span class="math notranslate nohighlight">\(z_v\)</span> values can produce the same <span class="math notranslate nohighlight">\(z_{ndc}\)</span> if the corresponding vertices are close to each other and far from the camera.</p>
<figure class="align-default">
<img alt="../../../_images/depth-precision.png" src="../../../_images/depth-precision.png" />
</figure>
<p>This can represent a serious problem because if a far object A is in front of another object B, but A is rendered after B, then A could be considered at the same distance as B with respect to the camera, and discarded from the pipeline if the depth test is enabled. We will delve into depth testing in a subsequent tutorial.</p>
<p>To mitigate the problem, we can set <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(f\)</span> to make the near and far planes as close as possible. In the illustration above, you can see what happens if we set <span class="math notranslate nohighlight">\(n=10\)</span> and <span class="math notranslate nohighlight">\(f=100\)</span>. The function grows slower, so we have a more even distribution of NDC values. Another mitigation technique is to redesign the projection matrix so that the clip space depths <span class="math notranslate nohighlight">\(z_c\)</span> are still mapped to <span class="math notranslate nohighlight">\([0,1]\)</span>, but in reverse order. That is, after the perspective division we have that <span class="math notranslate nohighlight">\(z_{ndc}\)</span> is a strictly decreasing function, where the NDC values are much more evenly distributed between near and far planes. Additional details on the inverse projection matrix will be provided in a subsequent tutorial.</p>
</section>
</section>
<section id="orthographic-projection">
<h3>Orthographic projection<a class="headerlink" href="#orthographic-projection" title="Link to this heading">#</a></h3>
<p>In an orthographic projection, we also want to lead the z-axis to pass through the center of the projection window, just like we made in the general case of a perspective projection. However, in an orthographic projection, we can move the projection window anywhere along the z-axis as its location doesn’t really matter. This is an interesting property that we will use to derive an equation for <span class="math notranslate nohighlight">\(z_{ndc}\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/ortho-proj.png" src="../../../_images/ortho-proj.png" />
</figure>
<p>Indeed, we can reuse equations <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces11}\)</span> through <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces14}\)</span> to make the z-axis pass through the center of the projection window and derive the first two NDC coordinates. However, this time we can’t reuse any equation formulated for the z-coordinate in the previous sections because they were derived in the context of a perspective projection (i.e., we found the variables <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span> inside a perspective projection matrix; see <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces6}\)</span>). With an orthographic projection, we can derive an equation for <span class="math notranslate nohighlight">\(z_{ndc}\)</span> by considering that we can move the projection window along the z-axis of the view space without any consequences. So, to map <span class="math notranslate nohighlight">\([n,f]\)</span> to <span class="math notranslate nohighlight">\([0,1]\)</span>, we can translate the coordinate <span class="math notranslate nohighlight">\(z_w\)</span> (similar to how we did with <span class="math notranslate nohighlight">\(x_w\)</span> and <span class="math notranslate nohighlight">\(y_w\)</span>) to make the x- and y-axes of the view space pass through the center of the box between the near and far planes. Then, we can scale the result by <span class="math notranslate nohighlight">\((f-n)^{-1}\)</span> (to normalize the range) and eventually translate it by <span class="math notranslate nohighlight">\(1/2\)</span> to shift from <span class="math notranslate nohighlight">\([-0.5, 0.5]\)</span> to <span class="math notranslate nohighlight">\([0, 1]\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
z_w&amp;=z_w-\frac{f+n}{2} \\ 
\\
z_{ndc}&amp;=\frac{z_w}{f-n}-\frac{f+n}{2\left(f-n\right)}+\frac{1}{2} \quad\quad\quad\quad\tag{18}\label{eq:ASpaces18}
\end{align*}
\end{split}\]</div>
<p>Observe that, with an orthographic projection, we can’t substitute <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces1}\)</span> and <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces2}\)</span> into <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces14}\)</span> and <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces13}\)</span> because, as illustrated in the image above, now we have <span class="math notranslate nohighlight">\(x_w=x_v\)</span> and <span class="math notranslate nohighlight">\(y_w=y_v\)</span>, along with <span class="math notranslate nohighlight">\(z_w=z_v\)</span> as we want to retain the depth value (i.e., we don’t project it onto the projection window). These are the values we need to plug into <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces14}\)</span>, <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces13}\)</span>, and <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces18}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
x_{ndc}&amp;=\frac{2\ x_v}{r-l}-\frac{2(r+l)}{2(r-l)}  \quad\quad\quad\quad\tag{19}\label{eq:ASpaces19} \\
\\
y_{ndc}&amp;=\frac{2\ y_v}{t-b}-\frac{2(t+b)}{2(t-b)}  \quad\quad\quad\quad\tag{20}\label{eq:ASpaces20} \\
\\
z_{ndc}&amp;=\frac{z_v}{f-n}-\frac{f+n}{2\left(f-n\right)}+\frac{1}{2}  \quad\quad\quad\quad\tag{21}\label{eq:ASpaces21}
\end{align*}
\end{split}\]</div>
<p>The result is that we no longer have <span class="math notranslate nohighlight">\(z_v\)</span> in the denominators of the NDC coordinates. This means the NDC coordinates can be expressed as a linear combination of the view coordinates, so that we can build our orthographic projection matrix directly from equations <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces19}\)</span>, <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces20}\)</span> and <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces21}\)</span>, defining the NDC coordinates.</p>
<div class="math notranslate nohighlight">
\[\mathbf{P}=\left\lbrack\matrix{\frac{2}{r-l}&amp;0&amp;0&amp;0\cr 0&amp;\frac{2}{t-b}&amp;0&amp;0\cr 0&amp;0&amp;\frac{1}{f-n}&amp;0\cr -\frac{r+l}{r-l}&amp;-\frac{t+b}{t-b}&amp;-\frac{n}{f-n}&amp;1}\right\rbrack \tag{22}\label{eq:ASpaces22} \]</div>
<p>This means that the matrix above allows us to go straight from view space to NDC space, without passing through the homogeneous clip space. Although, the rasterizer still expects vertices in clip coordinates. Then, we need a way to make the rasterizer believe we are passing clip coordinates, while also avoiding the perspective division. As you can see in the fourth column of the orthographic projection matrix <span class="math notranslate nohighlight">\(\eqref{eq:ASpaces22}\)</span>, the unitary value has moved in the last element. This means that if you multiply a vertex by this matrix you will get 1 in the last component of the resultant vector. That way, the rasterizer will divide the remaining components by 1, which nullifies the effect of the perspective division.</p>
</section>
<section id="projection-matrices-in-directx-wip">
<h3>Projection matrices in DirectX [WIP]<a class="headerlink" href="#projection-matrices-in-directx-wip" title="Link to this heading">#</a></h3>
<br>
<br>
<div class="admonition-support-this-project admonition">
<p class="admonition-title">Support this project</p>
<p>If you found the content of this tutorial somewhat useful or interesting, please consider supporting this project by clicking on the Sponsor button below. Whether a small tip, a one-time donation, or a recurring payment, all contributions are welcome! Thank you!</p>
<figure class="align-center">
<a class="reference external image-reference" href="https://github.com/sponsors/PAMinerva"><img alt="../../../_images/sponsor.png" src="../../../_images/sponsor.png" /></a>
</figure>
</div>
<br>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h2>
<div class="docutils container" id="id2">
<div role="list" class="citation-list">
<div class="citation" id="id13" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">MS22</a><span class="fn-bracket">]</span></span>
<p>S. Marschner and P. Shirley. <em>Fundamentals of Computer Graphics</em>. CRC Press, 4th edition, 2022.</p>
</div>
</div>
</div>
<br>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Tutorials\Appendices\01-MathBasics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="transformations.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Transformations</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#object-space">Object space</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#world-space-and-world-matrix">World space and World matrix</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#view-space-and-view-matrix">View space and View matrix</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#ndc-space-and-projection-matrix">NDC space and Projection matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#perspective-projection">Perspective projection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#general-case">General case</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#perspective-division-and-clipping">Perspective division and clipping</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#depth-buffer-precision">Depth buffer precision</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#orthographic-projection">Orthographic projection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#projection-matrices-in-directx-wip">Projection matrices in DirectX [WIP]</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By P. A. Minerva
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>