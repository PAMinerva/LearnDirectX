
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Vectors &#8212; Learn DirectX</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=bd9e20870c6007c4c509"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=afe5de03"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Tutorials/Appendices/01-MathBasics/vectors';</script>
    <link rel="icon" href="../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="prev" title="Math Basics" href="math-basics.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <header>


  <div class="bd-header-announcement container-fluid bd-header-announcement">
    <div class="bd-header-announcement__content">🚧 This documentation is a work in progress! 🚧</div>
  </div>

  
    <div class="bd-header navbar navbar-expand-lg bd-navbar">
    </div>
  
  </header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../presentation.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Learn DirectX - Home"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Learn DirectX - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../presentation.html">
                    Welcome to Learn DirectX
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../00-Intro/intro-and-prerequisites.html">Introduction and Prerequisites</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Hello DirectX</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../01-HelloWorld/hello-world.html">Hello World</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-window.html">Hello Window</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-triangle.html">Hello Triangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-bundles.html">Hello Bundles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-cbs.html">Hello Constant Buffers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-texture.html">Hello Texture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01-HelloWorld/hello-frame-buffering.html">Hello Frame Buffering</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="math-basics.html">Math Basics</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Vectors</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/PAMinerva/LearnDirectX" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/PAMinerva/LearnDirectX/issues/new?title=Issue%20on%20page%20%2FTutorials/Appendices/01-MathBasics/vectors.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/Tutorials/Appendices/01-MathBasics/vectors.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Vectors</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coordinate-systems">Coordinate systems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#d-coordinate-system">1D Coordinate system</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cartesian-coordinate-system">Cartesian coordinate system</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#polar-coordinate-system">Polar coordinate system</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cylindrical-and-spherical-coordinate-systems">Cylindrical and spherical coordinate systems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#homogeneous-coordinate-system">Homogeneous coordinate system</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Vectors</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#definition">Definition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-operations">Basic operations</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#addition-and-subtraction">Addition and Subtraction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#scalar-multiplication">Scalar multiplication</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#properties-of-addition-and-scalar-multiplication">Properties of addition and scalar multiplication</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#length-of-a-vector">Length of a vector</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dot-product">Dot product</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#properties-of-dot-multiplication">Properties of dot multiplication</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#orthogonal-projection">Orthogonal projection</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#gram-schmidt-orthogonalization">Gram-Schmidt Orthogonalization</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cross-product">Cross product</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#scalar-and-vector-triple-product">Scalar and vector triple product</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vectors-in-directx">Vectors in DirectX</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hlsl">HLSL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#c">C++</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="vectors">
<h1>Vectors<a class="headerlink" href="#vectors" title="Link to this heading">#</a></h1>
<section id="coordinate-systems">
<h2>Coordinate systems<a class="headerlink" href="#coordinate-systems" title="Link to this heading">#</a></h2>
<p>A coordinate system, often referred to as a reference frame (or simply as a frame or system for brevity), is a fundamental concept in mathematics and geometry. It provides a way to uniquely determine a position in space by using one or more numbers called coordinates.</p>
<p>To define a coordinate system, three key components are needed: an origin, a unit of measurement, and a positive direction. The origin is a reference point from which all positions are measured. The unit of measurement determines the scale or size of each coordinate value. The positive direction indicates how the coordinates increase from the origin.</p>
<p>By using a coordinate system, we can bridge the gap between geometry and numerical problems. Geometrical problems involving positions, distances, angles, and shapes can be translated into numerical problems by assigning coordinates to the geometric elements. Similarly, numerical problems can be visualized and understood geometrically by mapping the numbers that represent points and other geometric entities onto a coordinate system.</p>
<section id="d-coordinate-system">
<h3>1D Coordinate system<a class="headerlink" href="#d-coordinate-system" title="Link to this heading">#</a></h3>
<p>A 1D coordinate system is a reference frame that operates along a single dimension, typically represented by a straight line (but it can also be a curve). In a 1D coordinate system, an origin point is typically defined as a reference point for the line. This origin point serves as the starting point from which positions are measured. Additionally, it is necessary to establish a unit of measurement that determines the scale or increment used to quantify distances or positions along the line, and a positive direction indicating the way in which values increase from the origin. In this type of coordinate system, a position <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> on a line (or curve) can be determined with a single number (coordinate) <span class="math notranslate nohighlight">\(x\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/1D-coord-system.png" src="../../../_images/1D-coord-system.png" />
</figure>
<p>For instance, in the line illustrated above, <span class="math notranslate nohighlight">\(x=3\)</span> specifies that the position <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> is <span class="math notranslate nohighlight">\(3\)</span> units away from the origin <span class="math notranslate nohighlight">\(\mathbf{O}\)</span> in the positive direction along the line. This approach assigns a unique coordinate to each point\position on the line, and every real number representing the coordinate of a distinct point on the line. Therefore, the coordinate of a point <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> is defined as the signed distance between the origin <span class="math notranslate nohighlight">\(\mathbf{O}\)</span> and the point.</p>
</section>
<section id="cartesian-coordinate-system">
<h3>Cartesian coordinate system<a class="headerlink" href="#cartesian-coordinate-system" title="Link to this heading">#</a></h3>
<p>In two dimensiones (i.e., in a plane), two perpendicular lines (also called axes) define a system. We can express the coordinates <span class="math notranslate nohighlight">\((x, y)\)</span> of a point <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> as the signed distances between the origin <span class="math notranslate nohighlight">\(\mathbf{O}\)</span> and the projection of <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> onto the axes.</p>
<figure class="align-default">
<img alt="../../../_images/2D-coord-system.png" src="../../../_images/2D-coord-system.png" />
</figure>
<p>For example, point <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> in the illustration above has coordinates <span class="math notranslate nohighlight">\((2, 3)\)</span> because its projection is two units away from <span class="math notranslate nohighlight">\(\mathbf{O}\)</span> along the x-axis and three units away from <span class="math notranslate nohighlight">\(\mathbf{O}\)</span> along the y-axis.</p>
<p>In three dimensions, three mutually perpendicular axes define a system. The coordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span> of a point represent the signed distances between the origin <span class="math notranslate nohighlight">\(\mathbf{O}\)</span> and the projections of the point onto the axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To project a point <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> onto the x-axis, imagine first projecting the point perpendicularly onto the xz-plane, bringing you back to the 2D case. Then, project the result onto the x-axis. A similar approach can be used to compute the projection onto the other two axes.</p>
</div>
<p>You can also view the coordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span> as a series of steps from the origin <span class="math notranslate nohighlight">\(\mathbf{O}\)</span> to point <span class="math notranslate nohighlight">\(\mathbf{P}\)</span>:</p>
<ol class="arabic simple">
<li><p>Move <span class="math notranslate nohighlight">\(x\)</span> units along the x-axis.</p></li>
<li><p>From that position, move <span class="math notranslate nohighlight">\(y\)</span> units parallel to the y-axis.</p></li>
<li><p>Finally, move <span class="math notranslate nohighlight">\(z\)</span> units parallel to the z-axis.</p></li>
</ol>
<figure class="align-default">
<img alt="../../../_images/3D-coord-system.png" src="../../../_images/3D-coord-system.png" />
</figure>
<p>Depending on the direction and order of the axes, a three-dimensional system can be right-handed or left-handed.</p>
<figure class="align-default">
<img alt="../../../_images/handedness.png" src="../../../_images/handedness.png" />
</figure>
<p>Typically, the y-axis points up, the x-axis points right, and the z-axis points forward (note that forward aims at different directions depending on whether a right-handed or left-handed coordinate system is being used). However, this isn’t a strict rule. Sometimes, you can have the z-axis points up, and in that case the y-axis points forward. You can always switch from a y-up to a z-up configuration with a simple transformation, but there’s no point in providing further details here as we will use z-up or y-up configurations consistently during the rendering process (further details will be provided as needed).</p>
<p>It seems that DirectX programmers commonly use left-handed systems, so we’ll adopt this convention in this tutorial series. However, remember that right-handed systems are also valid for use in DirectX.</p>
</section>
<section id="polar-coordinate-system">
<h3>Polar coordinate system<a class="headerlink" href="#polar-coordinate-system" title="Link to this heading">#</a></h3>
<p>In a two-dimensional plane, we can define a coordinate system called the polar coordinate system. This system relies on two key elements:</p>
<ul class="simple">
<li><p>Origin (or pole): A fixed reference point.</p></li>
<li><p>Polar axis: A ray extending from the origin.</p></li>
</ul>
<p>A point <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> is identified by its polar coordinates, <span class="math notranslate nohighlight">\((r,\theta)\)</span>, where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(r\)</span>: Represents the distance from the origin to point P. This distance is also called the radius.</p></li>
<li><p><span class="math notranslate nohighlight">\(θ\)</span>: Represents the angle between the polar axis and the line segment connecting the origin and point P. This angle is usually measured in degrees or radians (<span class="math notranslate nohighlight">\(2\pi\)</span> radians =<span class="math notranslate nohighlight">\(360°\)</span>).</p></li>
</ul>
<figure class="align-default">
<img alt="../../../_images/polar-coord.png" src="../../../_images/polar-coord.png" />
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A single point can have multiple polar coordinate representations due to the periodicity of angles. For example, <span class="math notranslate nohighlight">\((r,\theta)\)</span> and <span class="math notranslate nohighlight">\((r,\theta + 2\pi)\)</span> represent the same point. Be aware of this when working with polar, cylindrical or spherical coordinates.</p>
</div>
</section>
<section id="cylindrical-and-spherical-coordinate-systems">
<h3>Cylindrical and spherical coordinate systems<a class="headerlink" href="#cylindrical-and-spherical-coordinate-systems" title="Link to this heading">#</a></h3>
<p>Extending polar coordinates, we can add an extra y-coordinate to specify the height from the plane containing origin and polar axis. This way, we can locate all points on a cylinder in three dimensions, hence the name “cylindrical coordinates” represented by the triple <span class="math notranslate nohighlight">\((r, y, \theta)\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/cylindrical-coord.png" src="../../../_images/cylindrical-coord.png" />
</figure>
<p>Build upon cylindrical coordinates, we can obtain spherical coordinates by converting the height <span class="math notranslate nohighlight">\(y\)</span> into and angle <span class="math notranslate nohighlight">\(\varphi\)</span> within the range <span class="math notranslate nohighlight">\([0, 180°]\)</span>. This gives us the triple <span class="math notranslate nohighlight">\((r, \varphi, \theta)\)</span>, which identifies all points on a sphere. The following illustration shows the conversion between spherical and Cartesian coordinates. Observe that the angle <span class="math notranslate nohighlight">\(\varphi\)</span> is measured from the upward direction.</p>
<figure class="align-default">
<img alt="../../../_images/cartesian2spherical.png" src="../../../_images/cartesian2spherical.png" />
</figure>
</section>
<section id="homogeneous-coordinate-system">
<h3>Homogeneous coordinate system<a class="headerlink" href="#homogeneous-coordinate-system" title="Link to this heading">#</a></h3>
<p>In homogeneous coordinates, a point in a plane can be represented by a triple <span class="math notranslate nohighlight">\((x, y, z)\)</span>. By dividing each coordinate by the z-coordinate, we can obtain the corresponding Cartesian coordinates: <span class="math notranslate nohighlight">\((x/z,\ y/z,\ z/z)\)</span>. Obviously, this approach introduces an additional coordinate, even though typically only two coordinates are used to specify a point in a two-dimensional space. Nevertheless, homogeneous coordinates enable us to express various transformations, such as scaling, rotation, and translation, in a simple and consistent way using matrices.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>In general, a homogeneous coordinate system is a frame where only the ratios of the coordinates are significant, rather than their actual values.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>After performing the division to obtain the Cartesian coordinates, the last coordinate will always be 1. This concept extends to three-dimensional spaces as well. Therefore, if we have the 3D Cartesian coordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span>, we can also express them as <span class="math notranslate nohighlight">\((x, y, z, 1)\)</span>.</p>
</div>
<br>
</section>
</section>
<section id="id1">
<h2>Vectors<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<p>Vectors are mathematical objects that represent quantities with both magnitude and direction. They are used in many fields, including physics and computer graphics. For example, vectors can be used to specify the position and displacement of objects, as well as their speed. They can also describe the direction and intensity of forces acting on objects or light rays emitted by a light source, as well as surface normals.</p>
<section id="definition">
<h3>Definition<a class="headerlink" href="#definition" title="Link to this heading">#</a></h3>
<p>Geometrically, a vector can be visualized as an arrow. The length of the arrow represents the magnitude or size of the vector, while the direction in which the arrow points indicates the direction of the vector.</p>
<figure class="align-default">
<img alt="../../../_images/geo-vector.png" src="../../../_images/geo-vector.png" />
</figure>
<p>When working with vectors for numerical computation on a computer, the geometric definition provided above is not as important, although. Fortunately, we can express vectors numerically using tuples, which are finite sequences of numbers. To establish this numerical representation, we need to bind vectors to the origin of a Cartesian coordinate system. In other words, we translate a vector while maintaining its magnitude and direction until its starting point aligns with the origin.</p>
<figure class="align-default">
<img alt="../../../_images/num-vector.png" src="../../../_images/num-vector.png" />
</figure>
<p>At that point, we can use the coordinates <span class="math notranslate nohighlight">\((x, y)\)</span> of the head of a generic vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> in a 2D Cartesian system as the numerical representation of the vector in that system. That is, we can write <span class="math notranslate nohighlight">\(\mathbf{v}=(x, y)\)</span>, with <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> called components of the vector. Similarly, for a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> in a 3D Cartesian system, the numerical representation would be <span class="math notranslate nohighlight">\((x, y, z)\)</span>. Then, we can use <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> to specify a point in a frame (maybe to set the position of an object, or a target location for movement).</p>
<figure class="align-default">
<img alt="../../../_images/vector-point.png" src="../../../_images/vector-point.png" />
</figure>
<p>When only magnitude and direction of a vector matter, then the point of application is of no importance, and the vector is called <strong>free vector</strong>. On the other hand, a vector bound to the origin of a system is called <strong>bound vector</strong>. The numerical representation of a bound vector is only valid in the system where it is bound. If the same free vector is bound to different systems, its numerical representation will change accordingly.</p>
<figure class="align-default">
<img alt="../../../_images/vector-free-bound.png" src="../../../_images/vector-free-bound.png" />
</figure>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>This is an important point to remember: if you define a vector numerically, its coordinates are relative to a specific reference frame. Therefore, we can conclude that two vectors <span class="math notranslate nohighlight">\(\mathbf{u}=(u_x, u_y, u_z)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}=(v_x, v_y, v_z)\)</span> are equal only if <span class="math notranslate nohighlight">\(u_x=v_x\)</span>, <span class="math notranslate nohighlight">\(u_y=v_y\)</span> and <span class="math notranslate nohighlight">\(u_z=v_z\)</span>. In other words, they have equal coordinates if bound to the origin of the same frame.</p>
</div>
</section>
<section id="basic-operations">
<h3>Basic operations<a class="headerlink" href="#basic-operations" title="Link to this heading">#</a></h3>
<p>Vectors support various interesting operations, including addition, subtraction, and three types of multiplication.</p>
<section id="addition-and-subtraction">
<h4>Addition and Subtraction<a class="headerlink" href="#addition-and-subtraction" title="Link to this heading">#</a></h4>
<p>Numerically, the sum of two vectors <span class="math notranslate nohighlight">\(\mathbf{u}=(u_x, u_y, u_z)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}=(v_x, v_y, v_z)\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[\mathbf{u}+\mathbf{v}=(u_x+v_x,\ u_y+v_y,\ u_z+v_z)\]</div>
<p>The addition may be represented geometrically by placing the tail of the arrow representing <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> at the head of the arrow representing <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>, and then drawing an arrow from the tail of <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> to the head of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. This arrow represent a new vector as the sum of <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. Alternatively, we can bind <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> to a shared point and then draw the diagonal of the parallelogram with sides <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/vector-sum.png" src="../../../_images/vector-sum.png" />
</figure>
<p>The difference between two vectors <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[\mathbf{u}-\mathbf{v}=(u_x-v_x,\ u_y-v_y,\ u_z-v_z)\]</div>
<p>Geometrically, the vector subtraction can be defined by bounding <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> to a shared point and drawing an arrow from the head of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> to the head of <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>. Alternatively, it can be treated as a sum <span class="math notranslate nohighlight">\((\mathbf{u}+(-\mathbf{v}))\)</span> by placing the tail of the inverse of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> at the head of <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>. At that point, we can draw an arrow from the tail of <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> to the head of <span class="math notranslate nohighlight">\(-\mathbf{v}\)</span>. This arrow represent a new vector as the difference between <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. The inverse of a vector will be formally defined in the next section.</p>
<figure class="align-default">
<img alt="../../../_images/vector-sub.png" src="../../../_images/vector-sub.png" />
</figure>
</section>
<section id="scalar-multiplication">
<h4>Scalar multiplication<a class="headerlink" href="#scalar-multiplication" title="Link to this heading">#</a></h4>
<p>We can multiply a vector <span class="math notranslate nohighlight">\(\mathbf{v}=(x, y, z)\)</span> by a real number <span class="math notranslate nohighlight">\(k\)</span> called scalar. Numerically, this operation is defined as</p>
<div class="math notranslate nohighlight">
\[k\mathbf{v}=k(x,y,z)=(kx,ky,kz)\]</div>
<p>Geometrically, this is equivalent to scaling a vector, which is why real numbers are often called scalars. If <span class="math notranslate nohighlight">\(k\)</span> is negative, the resulting vector will aim in the opposite direction as well. In particular, if <span class="math notranslate nohighlight">\(k=−1\)</span> we get the inverse <span class="math notranslate nohighlight">\(-\mathbf{v}\)</span> of a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, which aims in the opposite direction without changing its length.</p>
<figure class="align-default">
<img alt="../../../_images/vector-mul.png" src="../../../_images/vector-mul.png" />
</figure>
<section id="properties-of-addition-and-scalar-multiplication">
<h5>Properties of addition and scalar multiplication<a class="headerlink" href="#properties-of-addition-and-scalar-multiplication" title="Link to this heading">#</a></h5>
<p>Here are some of the properties of vector addition and scalar multiplication:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Commutative (vector)</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{u}+\mathbf{v}=\mathbf{v}+\mathbf{u}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Associative (vector)</p></td>
<td><p><span class="math notranslate nohighlight">\((\mathbf{u}+\mathbf{v})+\mathbf{w}=\mathbf{u}+(\mathbf{v}+\mathbf{w})\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Additive Identity</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{v}+\mathbf{0}=\mathbf{v}\)</span>  (where <span class="math notranslate nohighlight">\(\mathbf{0}\)</span> is the zero (or null) vector, whose components are all zero)</p></td>
</tr>
<tr class="row-odd"><td><p>Distributive (vector)</p></td>
<td><p><span class="math notranslate nohighlight">\(k(\mathbf{u}+\mathbf{v})=k\mathbf{u}+k\mathbf{v}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Distributive (scalar)</p></td>
<td><p><span class="math notranslate nohighlight">\((k+t)\mathbf{v}=k\mathbf{v}+t\mathbf{v}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Associative (scalar)</p></td>
<td><p><span class="math notranslate nohighlight">\(k(t\mathbf{v})=(kt)\mathbf{v}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Multiplicative Identity</p></td>
<td><p><span class="math notranslate nohighlight">\(1\mathbf{v}=\mathbf{v}\)</span>   (where <span class="math notranslate nohighlight">\(k=1\)</span> is a scalar)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="length-of-a-vector">
<h5>Length of a vector<a class="headerlink" href="#length-of-a-vector" title="Link to this heading">#</a></h5>
<p>Now, we can define the length of a vector <span class="math notranslate nohighlight">\(|v|\)</span> (or <span class="math notranslate nohighlight">\(\|v\|\)</span>) as a scalar value that represents the magnitude of the vector. Consider the following illustration.</p>
<figure class="align-default">
<img alt="../../../_images/vector-length.png" src="../../../_images/vector-length.png" />
</figure>
<p>We have that <span class="math notranslate nohighlight">\(a\)</span> is the length of the projection of the vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> onto the xz-plane. From the Pythagorean theorem, <span class="math notranslate nohighlight">\(a=\sqrt{x^2+z^2}\)</span>. Then, applying the same theorem once again, we have that</p>
<div class="math notranslate nohighlight">
\[|\mathbf{v}|=\sqrt{y^2+a^2}=\sqrt{y^2+(\sqrt{x^2+z^2})^2}=\sqrt{x^2+y^2+z^2}\]</div>
<p>Sometimes, only the direction of a vector is relevant. In such cases, we can normalize the vector to ensure its length becomes 1. Usually, the symbol <span class="math notranslate nohighlight">\(\hat{\mathbf{v}}\)</span> is used to indicate a unit vector (a vector with length 1). To normalize a vector <span class="math notranslate nohighlight">\(\mathbf{v}=(x, y, z)\)</span>, we can multiply it by the reciprocal of its magnitude.</p>
<div class="math notranslate nohighlight">
\[\displaystyle\hat{\mathbf{v}}=\frac{\mathbf{v}}{|\mathbf{v}|}=\left(\frac{x}{|\mathbf{v}|},\frac{y}{|\mathbf{v}|},\frac{z}{|\mathbf{v}|}\right)\]</div>
<p>We can verify that <span class="math notranslate nohighlight">\(\hat{\mathbf{v}}\)</span> is a unit vector by computing its length.</p>
<div class="math notranslate nohighlight">
\[\displaystyle|\hat{\mathbf{v}}|=\sqrt{\left(\frac{x}{|\mathbf{v}|}\right)^2+\left(\frac{y}{|\mathbf{v}|}\right)^2+\left(\frac{z}{|\mathbf{v}|}\right)^2}=\frac{\sqrt{x^2+y^2+z^2}}{\sqrt{|\mathbf{v}|^2}}=\frac{|\mathbf{v}|}{|\mathbf{v}|}=1\]</div>
<p>Three significant unit vectors are: <span class="math notranslate nohighlight">\(\mathbf{i}=(1,0,0)\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}=(0,1,0)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{k}=(0,0,1)\)</span>. These vectors have unit lengths and align with the x-, y-, and z-axes, respectively, in a 3D Cartesian coordinate system. They are commonly referred to as the <strong>standard basis vectors</strong> of a coordinate system.</p>
<figure class="align-default">
<img alt="../../../_images/basis-vectors.png" src="../../../_images/basis-vectors.png" />
</figure>
</section>
</section>
<section id="dot-product">
<h4>Dot product<a class="headerlink" href="#dot-product" title="Link to this heading">#</a></h4>
<p>The dot product is a form of vector multiplication that results in a scalar value ─ it is also known as the scalar product for this reason. The dot product of two vector <span class="math notranslate nohighlight">\(\mathbf{u}=(u_x, u_y, u_z)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}=(v_x, v_y, v_z)\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[\mathbf{u}\cdot\mathbf{v}=u_xv_x+u_yv_y+u_zv_z\]</div>
<p>In essence, the dot product of two vectors is obtained by summing the products of the corresponding components.</p>
<section id="properties-of-dot-multiplication">
<h5>Properties of dot multiplication<a class="headerlink" href="#properties-of-dot-multiplication" title="Link to this heading">#</a></h5>
<p>Below are some of the properties of the dot product:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Commutative</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{u}\cdot\mathbf{v}=\mathbf{v}\cdot\mathbf{u}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Distributive</p></td>
<td><p><span class="math notranslate nohighlight">\((\mathbf{u}+\mathbf{v})\cdot\mathbf{w}=\mathbf{w}\cdot(\mathbf{u}+\mathbf{v})=(\mathbf{w}\cdot\mathbf{u})+(\mathbf{w}\cdot\mathbf{v})\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Square of a vector length</p></td>
<td><p><span class="math notranslate nohighlight">\(|\mathbf{v}| ^2=v_x^2+v_y^2+v_z^2=\mathbf{v}\cdot\mathbf{v}\)</span></p></td>
</tr>
</tbody>
</table>
<br>
<p>The associative property doesn’t apply because <span class="math notranslate nohighlight">\(\mathbf{w}\cdot(\mathbf{u}\cdot\mathbf{v})\)</span> is not defined. Indeed, the dot product is defined as an operation between two vectors, but <span class="math notranslate nohighlight">\((\mathbf{u}\cdot\mathbf{v})\)</span> yields a scalar value.</p>
<p>Moreover, from the law of cosines <span class="math notranslate nohighlight">\(c^2=a^2+b^2-2ab\cos{\theta}\)</span> (a proof is provided at the end of the section), we can show that</p>
<div class="math notranslate nohighlight">
\[\begin{equation}\tag{1}\mathbf{v}\cdot\mathbf{u}=|\mathbf{v}| |\mathbf{u}|\cos{\theta}\label{eq:Avectors1}\end{equation}\]</div>
<p>Indeed, if we set <span class="math notranslate nohighlight">\(a=|\mathbf{u}|\)</span>, <span class="math notranslate nohighlight">\(b=|\mathbf{v}|\)</span> and <span class="math notranslate nohighlight">\(c=|\mathbf{u}-\mathbf{v}|\)</span> we have that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*} c^2 &amp;= a^2 + b^2 - 2ab \cos{\theta} \\ 
|\mathbf{u-v}|^2 &amp;= |\mathbf{u}|^2 + |\mathbf{v}|^2 - 2|\mathbf{u}| |\mathbf{v}|\cos{\theta} \\ 
(\mathbf{u} - \mathbf{v}) \cdot (\mathbf{u} - \mathbf{v}) &amp;= \mathbf{u} \cdot \mathbf{u} + \mathbf{v} \cdot \mathbf{v} - 2|\mathbf{u}| |\mathbf{v}|\cos{\theta} \\ 
\mathbf{u} \cdot\mathbf{u} -2(\mathbf{u} \cdot \mathbf{v}) + \mathbf{v} \cdot \mathbf{v} &amp;= \mathbf{u} \cdot \mathbf{u} + \mathbf{v} \cdot \mathbf{v} - 2|\mathbf{u}| |\mathbf{v}|\cos{\theta} \\
 \mathbf{u}\cdot \mathbf{v} &amp;= |\mathbf{u}| |\mathbf{v}|\cos{\theta} \end{align*}
\end{split}\]</div>
<p>From equation <span class="math notranslate nohighlight">\(\eqref{eq:Avectors1}\)</span>, we can derive other properties. For example,</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\((\mathbf{u}\cdot\mathbf{v}) = 0\)</span> then the angle <span class="math notranslate nohighlight">\(\theta\)</span> between <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is <span class="math notranslate nohighlight">\(90°\)</span> (that is, they are orthogonal: <span class="math notranslate nohighlight">\(\mathbf{u}\ \bot\ \mathbf{v}\)</span>)</p></li>
<li><p>If <span class="math notranslate nohighlight">\((\mathbf{u}\cdot\mathbf{v}) &gt; 0\)</span> then the angle <span class="math notranslate nohighlight">\(\theta\)</span> between <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is less than <span class="math notranslate nohighlight">\(90°\)</span></p></li>
<li><p>If <span class="math notranslate nohighlight">\((\mathbf{u}\cdot\mathbf{v}) &lt; 0\)</span> then the angle <span class="math notranslate nohighlight">\(\theta\)</span> between <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is greater than <span class="math notranslate nohighlight">\(90°\)</span></p></li>
</ul>
<p>To conclude this section, we will prove the law of cosines: <span class="math notranslate nohighlight">\(c^2=a^2+b^2-2ab\cos{\theta}\)</span>.</p>
<div class="dropdown admonition">
<p class="admonition-title">Proof</p>
<p>Let <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> be the vector from <span class="math notranslate nohighlight">\(C\)</span> to <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> the vector from <span class="math notranslate nohighlight">\(C\)</span> to <span class="math notranslate nohighlight">\(A\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> the vector from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/law-cosines.png" src="../../../_images/law-cosines.png" />
</figure>
<p>We have that</p>
<div class="math notranslate nohighlight">
\[\begin{align*}&amp;\mathbf{c}=\mathbf{a}-\mathbf{b} &amp;&amp; \text{(subtration of two vectors)}\end{align*}\]</div>
<p>Squaring both sides and simplifying</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
&amp;|\mathbf{c}|^2=|\mathbf{a}-\mathbf{b}|^2 \\
&amp;|\mathbf{c}|^2=(\mathbf{a}-\mathbf{b})\cdot (\mathbf{a}-\mathbf{b}) &amp;&amp; \text{(square of a vector length)} \\
&amp;|\mathbf{c}|^2=|\mathbf{a}|^2+|\mathbf{b}|^2-2\ \mathbf{a}\cdot\mathbf{b} &amp;&amp; \text{(distributive law of the dot product)} \\
&amp;|\mathbf{c}|^2=|\mathbf{a}|^2+|\mathbf{b}|^2-2|\mathbf{a}||\mathbf{b} | \cos{\theta} &amp;&amp; \text{(from equation \eqref{eq:Avectors1})}
\end{align*}
\end{split}\]</div>
</div>
</section>
<section id="orthogonal-projection">
<h5>Orthogonal projection<a class="headerlink" href="#orthogonal-projection" title="Link to this heading">#</a></h5>
<p>The orthogonal projection of a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> onto another vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> is defined as the vector <span class="math notranslate nohighlight">\(\text{proj}_\mathbf{n}(\mathbf{v})\)</span>. Consider the following illustration.</p>
<figure class="align-default">
<img alt="../../../_images/vector-proj.png" src="../../../_images/vector-proj.png" />
</figure>
<p>From trigonometry, we know that, in a right triangle, the cosine of an angle equals the ratio between the length of the adjacent side and the length of the hypotenuse. Therefore, we can calculate the length of the adjacent side by multiplying the length of the hypotenuse by the cosine of the angle between the adjacent side and the hypotenuse. Considering the image above, we have that <span class="math notranslate nohighlight">\(|\text{adj}|=|\text{proj}_\mathbf{n}(\mathbf{v})|\)</span> and <span class="math notranslate nohighlight">\(|\text{hyp}|=|\mathbf{v}|\)</span>. So, if <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> is a unit vector, we can write</p>
<div class="math notranslate nohighlight">
\[\text{proj}_\mathbf{n}(\mathbf{v})=(|\mathbf{v}|\cos{\theta})\mathbf{n}=(|\mathbf{v}|1\cos{\theta})\mathbf{n}=(|\mathbf{v}||\mathbf{n}|\cos{\theta})\mathbf{n}=(\mathbf{v}\cdot\mathbf{n})\mathbf{n}\]</div>
<p>with <span class="math notranslate nohighlight">\((\mathbf{v}\cdot\mathbf{n})\)</span> signed length of the projection, and <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> that indicates its direction. This means that <span class="math notranslate nohighlight">\((\mathbf{v}\cdot\mathbf{n})\)</span> can invert the direction of projection if <span class="math notranslate nohighlight">\(\theta &gt; 90°\)</span>. Anyway, this gives us a geometrical interpretation of the dot product, at least if <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> is a unit vector. If that’s not the case, we can always normalize <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> to make it unit length. Then, we can replace <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> with its normalized version <span class="math notranslate nohighlight">\(\mathbf{n}/|\mathbf{n}|\)</span>, giving us the more general formula</p>
<div class="math notranslate nohighlight">
\[\text{proj}_\mathbf{n}(\mathbf{v})=\left(\mathbf{v}\cdot\displaystyle\frac{\mathbf{n}}{|\mathbf{n}|}\right)\displaystyle\frac{\mathbf{n}}{|\mathbf{n}|}=\displaystyle\frac{(\mathbf{v}\cdot\mathbf{n})}{|\mathbf{n}|^2}\mathbf{n}\]</div>
<p>Thanks to the concept of orthogonal projection, we can express any bound vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> as the sum of its projections onto the standard basis vectors as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}=(\mathbf{v}\cdot\mathbf{i})\mathbf{i}+(\mathbf{v}\cdot\mathbf{j})\mathbf{j}+(\mathbf{v}\cdot\mathbf{k})\mathbf{k}=x\mathbf{i}+y\mathbf{j}+z\mathbf{k}=x(1, 0, 0)+y(0, 1, 0)+z(0, 0, 1)=(x, y, z)\]</div>
<p>Indeed, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
&amp;(\mathbf{v}\cdot\mathbf{i})&amp;=(x, y, z)\cdot(1, 0, 0)&amp;=x \\
&amp;(\mathbf{v}\cdot\mathbf{j})&amp;=(x, y, z)\cdot(0, 1, 0)&amp;=y \\
&amp;(\mathbf{v}\cdot\mathbf{k})&amp;=(x, y, z)\cdot(0, 0, 1)&amp;=z
\end{flalign}
\end{split}\]</div>
<p>Also, note that <span class="math notranslate nohighlight">\((x\mathbf{i}+z\mathbf{k})\)</span> is the projection of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> onto the xz-plane, so that we can sum this projection with <span class="math notranslate nohighlight">\(y\mathbf{j}\)</span> to get <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/vector-proj2.png" src="../../../_images/vector-proj2.png" />
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can also see it as a sum of scaled vectors: we scale <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> with the corresponding components of <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. Indeed, the diagonal of the parallelogram defined by <span class="math notranslate nohighlight">\(x\mathbf{i}\)</span> and <span class="math notranslate nohighlight">\(z\mathbf{k}\)</span> is <span class="math notranslate nohighlight">\((x\mathbf{i}+z\mathbf{k})\)</span>, while <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is the diagonal of the parallelogram defined by <span class="math notranslate nohighlight">\((x\mathbf{i}+z\mathbf{k})\)</span> and <span class="math notranslate nohighlight">\(y\mathbf{j}\)</span>, that is <span class="math notranslate nohighlight">\(\ x\mathbf{i}+z\mathbf{k}+y\mathbf{j}\)</span>.</p>
</div>
<p>As mentioned earlier, you can express every vector as a sequence of three steps\translations: starting from the origin of the frame, we move <span class="math notranslate nohighlight">\(x\)</span> units along the x-axis. Then, from that position, we move <span class="math notranslate nohighlight">\(y\)</span> units in the y-axis direction, and finally, you move <span class="math notranslate nohighlight">\(z\)</span> units in the z-axis direction. This is why we refer to <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> as basis vectors: any bound vector in a frame can be expressed as a combination of these three unit vectors, with the components of the vector acting as coefficients.</p>
<p>The components of a bound vector represent the coordinates of its arrowhead within the frame. This allows us to uniquely identify all points within a frame using vector notation. However, we still need a way to distinguish between vectors and points, as they are not interchangeable. For vectors, only their direction and magnitude matter, making the point of application irrelevant. On the other hand, points uniquely represent a location and only make sense when bound to the origin of a frame. Subtracting points yields a vector that specifies the movement from one point to another, while adding a point and a vector gives a vector that specifies how to move a point to a different location. However, unlike vectors, adding two points does not have a meaningful interpretation ─ geometrically it’s the diagonal of a parallelogram, but this interpretation is not particularly useful or relevant when working with points.</p>
<p>In summary, consider vectors as free vectors and points as bound vectors. When working with a generic vector <span class="math notranslate nohighlight">\(\mathbf{v}=(x, y, z)\)</span>, it is crucial to determine whether it represents a point or a vector to use it appropriately. The distinction between points and vectors will be further explored in a later tutorial.</p>
</section>
<section id="gram-schmidt-orthogonalization">
<h5>Gram-Schmidt Orthogonalization<a class="headerlink" href="#gram-schmidt-orthogonalization" title="Link to this heading">#</a></h5>
<p>A computer cannot exactly represent all elements in the infinite set of real numbers because it uses a finite number of bits to store values in memory. This means that we must to settle for good approximations. The downside is that, if you need to perform many calculations with approximate values, the outcome could differ significantly from the exact result. For example, a set of vectors <span class="math notranslate nohighlight">\(\{\mathbf{v_0},\dots,\mathbf{v_{n-1}}\}\)</span> is called <strong>orthonormal</strong> if they are all unit vectors and orthogonal to each other. However, due to numerical precision issues, we might start off with an orthonormal set that gradually becomes un-orthonormal after some transformations. Fortunately, there are methods available to orthogonalize a set of vectors to restore its orthonormality. While our primary focus will be on the 3D case, it is often helpful to start by examining the simpler 2D case.</p>
<p>Suppose we have an initial set of vectors <span class="math notranslate nohighlight">\(\{\mathbf{v_0},\mathbf{v_1}\}\)</span> that is not orthonormal, and we want to orthogonalize it to obtain an orthonormal set <span class="math notranslate nohighlight">\(\{\mathbf{w_0},\mathbf{w_1}\}\)</span>. To begin the orthogonalization process, we can set <span class="math notranslate nohighlight">\(\mathbf{w_0}=\mathbf{v_0}\)</span>, as we can always assume one of the vectors in the set is already acceptable. Next, we aim to make <span class="math notranslate nohighlight">\(\mathbf{v_1}\)</span> orthogonal to <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span>. This can be achieved by subtracting from <span class="math notranslate nohighlight">\(\mathbf{v_1}\)</span> its projection onto <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span>. By doing so, we obtain a new vector <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span> that is orthogonal to <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span>. Indeed, in the following illustration, you can verify that</p>
<div class="math notranslate nohighlight">
\[\mathbf{v_1}=\mathbf{w_1}+\text{proj}_{\mathbf{w_0}}(\mathbf{v_1})\]</div>
<figure class="align-default">
<img alt="../../../_images/2D-Gram-Schmidt.png" src="../../../_images/2D-Gram-Schmidt.png" />
</figure>
<p>So, we have that</p>
<br>
<div class="math notranslate nohighlight">
\[\mathbf{w_1}=\mathbf{v_1}-\text{proj}_{\mathbf{w_0}}(\mathbf{v_1})\]</div>
<br>
<p>where <span class="math notranslate nohighlight">\(\ \text{proj}_{\mathbf{w_0}}(\mathbf{v_1})=\displaystyle\frac{\mathbf{v_1}\cdot\mathbf{w_0}}{|\mathbf{w_0}|^2}\mathbf{w_0}\)</span></p>
<p>To prove that <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span> are orthogonal to each other, we can first observe that a projection is orthogonal if the direction of projection forms a right angle <span class="math notranslate nohighlight">\((90°)\)</span> with the vector we project onto (see the dashed line in the illustration above). Also, we know that the sum of two vectors is the diagonal of the parallelogram with sides the two vectors. In this case we obtain a rectangle since we just established that an angle of the parallelogram with diagonal <span class="math notranslate nohighlight">\(v_1\)</span> is <span class="math notranslate nohighlight">\(90°\)</span>. So, we verified that <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span> are orthogonal: <span class="math notranslate nohighlight">\(\mathbf{w_0}\ \bot\ \mathbf{w_1}\)</span>.</p>
<p>In the 3D case, we introduce a third vector <span class="math notranslate nohighlight">\(\mathbf{v_2}\)</span> that we need to modify in order to make it orthogonal to both <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span>. As before, we start by setting <span class="math notranslate nohighlight">\(\mathbf{w_0}=\mathbf{v_0}\)</span>, and we can still use the method of subtracting the projection of <span class="math notranslate nohighlight">\(\mathbf{v_1}\)</span> onto <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span> to compute <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span>. This is possible because we can consider <span class="math notranslate nohighlight">\(\mathbf{v_0}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v_1}\)</span> as lying in the same plane, thereby reducing the problem to the 2D case. To calculate <span class="math notranslate nohighlight">\(\mathbf{w_2}\)</span>, we proceed similarly. We subtract the projection of <span class="math notranslate nohighlight">\(\mathbf{v_2}\)</span> onto <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span> from <span class="math notranslate nohighlight">\(\mathbf{v_2}\)</span>, obtaining an intermediate vector. Then, we can subtract the projection of <span class="math notranslate nohighlight">\(\mathbf{v_2}\)</span> onto <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span> from this intermediate vector. By doing this, we ensure that the resultant vector <span class="math notranslate nohighlight">\(\mathbf{w_2}\)</span> is orthogonal to both <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{w_2}=\mathbf{v_2}-\text{proj}_{\mathbf{w_0}}(\mathbf{v_2}) -\text{proj}\_{\mathbf{w_1}}(\mathbf{v_2})\]</div>
<p>Consider the illustration below. If we subtract <span class="math notranslate nohighlight">\(\text{proj}\_{\mathbf{w_0}}(\mathbf{v_2})\)</span> from <span class="math notranslate nohighlight">\(\mathbf{v_2}\)</span> the resultant vector is orthogonal to <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span> and lies in the YZ-plane. Then, if we subtract <span class="math notranslate nohighlight">\(\text{proj}\_{\mathbf{w_1}}(\mathbf{v_2})\)</span> from this intermediate vector, we get <span class="math notranslate nohighlight">\(\mathbf{w_2}\)</span>, which is orthogonal to both <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span>.</p>
<figure class="align-default">
<img alt="../../../_images/3D-Gram-Schmidt.png" src="../../../_images/3D-Gram-Schmidt.png" />
</figure>
<p>The final step in the process of orthogonalization is to normalize the vectors <span class="math notranslate nohighlight">\(\mathbf{w_0}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{w_1}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{w_2}\)</span> to obtain an orthonormal set.</p>
</section>
</section>
<section id="cross-product">
<h4>Cross product<a class="headerlink" href="#cross-product" title="Link to this heading">#</a></h4>
<p>This type of multiplication, also known as the vector product, differs from the dot product by resulting in a vector instead of a scalar. It’s defined as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}=\mathbf{u}\times\mathbf{v}=(u_y v_z-u_z v_y,\ u_z v_x-u_x v_z,\ u_x v_y-u_y v_x)\]</div>
<p>A way to remember this formula is to notice that the first component of the vector <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> is missing the subscript <span class="math notranslate nohighlight">\(x\)</span>, the second component is missing the subscript <span class="math notranslate nohighlight">\(y\)</span>, and the third component is missing the subscript <span class="math notranslate nohighlight">\(z\)</span>. The trick works by using the subscripts <span class="math notranslate nohighlight">\(\{x,y,z\}\)</span> as a circular sequence. For example, in the first component of <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> we exclude the subscript <span class="math notranslate nohighlight">\(x\)</span>, so we start with <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> in the minuend, inverting the subscripts in the subtrahend. In the second component we exclude the subscript <span class="math notranslate nohighlight">\(y\)</span>, so we start with <span class="math notranslate nohighlight">\(z\)</span> and <span class="math notranslate nohighlight">\(x\)</span> in the minuend, inverting the subscripts in the subtrahend. You can easily conclude that the third component starts with <span class="math notranslate nohighlight">\(x\)</span>, followed by <span class="math notranslate nohighlight">\(y\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We can also use matrices to calculate the cross product. For example, the cross product <span class="math notranslate nohighlight">\(\mathbf{u}\times\mathbf{v}\)</span> is equal to the determinant of the <span class="math notranslate nohighlight">\(3\times 3\)</span> matrix with <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> as elements of the first row, and the components of the two vectors <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> as elements of the other two rows.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
\mathbf{w}=\mathbf{u}\times\mathbf{v}&amp;=\left\lvert\matrix{\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \cr u_x &amp; u_y &amp; u_z \cr v_x &amp; v_y &amp; v_z}\right\rvert \\ \\
&amp;=(u_y v_z-u_z v_y)\mathbf{i}-(u_x v_z-u_z v_x)\mathbf{j}+(u_x v_y-u_y v_x)\mathbf{k} \\
&amp;=(u_y v_z-u_z v_y,\ u_z v_x-u_x v_z,\ u_x v_y-u_y v_x)
\end{flalign}
\end{split}\]</div>
<p>Also, the cross product can be computed multiplying a matrix by a column.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\mathbf{w}=\mathbf{u}\times\mathbf{v}&amp;=\left\lbrack\matrix{0&amp;-u_z&amp;u_y \cr u_z&amp;0&amp;-u_x \cr -u_y&amp;u_x&amp;0}\right\rbrack\left\lbrack\matrix{v_x\cr v_y\cr v_z}\right\rbrack \\ \\
&amp;=(u_yv_z-u_zv_y,\ u_zv_x-u_xv_z,\ u_xv_y-u_yv_x)
\end{align*}
\end{split}\]</div>
</div>
<p>We will cover matrices in the next appendix, where we will show that the determinant of a matrix is related to the concept of hypervolume (that is, length in 1D, area in 2D, and volume in 3D). However, in this section we can use the information provided in the box note above to find something interesting. We know that two vectors always lie in a plane, and that to calculate the area of a parallelogram we multiply its base times the height. Then, we are supposed to find a similar formula for the cross product because, to compute it, we can use the determinant of a matrix, which is related to the concept of hypervolume (area in the 2D case). Indeed, we can also write the cross product as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}=\mathbf{u}\times\mathbf{v}=\mathbf{n}|\mathbf{u}||\mathbf{v}|\sin{\theta}\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> unit vector indicating the direction of <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>, and with <span class="math notranslate nohighlight">\(|\mathbf{u}||\mathbf{v}|\sin{\theta}\)</span> indicating the length of <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>. The vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> is often called normal, which means it is orthogonal to the surface it refers to (in this case, the plane defined by <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>). Now, we need to find a connection between the above formula and the area <span class="math notranslate nohighlight">\(A_p\)</span> of the parallelogram with sides <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. Consider the following illustration.</p>
<figure class="align-default">
<img alt="../../../_images/cross-product.png" src="../../../_images/cross-product.png" />
</figure>
<p>We know that <span class="math notranslate nohighlight">\(A_p=b\times h\)</span>, so we should have something like</p>
<div class="math notranslate nohighlight">
\[A_p=|\mathbf{w}|=|\mathbf{u}\times\mathbf{v}|=|\mathbf{u}||\mathbf{v}|\sin{\theta}\]</div>
<p>since <span class="math notranslate nohighlight">\(|\mathbf{n}|=1\)</span> and the area of a parallelogram is a scalar value, so that we must consider the length of the cross product. As you can see in the illustration above, we have <span class="math notranslate nohighlight">\(|\mathbf{v}|=b\)</span> and <span class="math notranslate nohighlight">\(|\mathbf{u}|\sin{\theta}=h\)</span>. So, it’s <span class="math notranslate nohighlight">\(A_p=|\mathbf{w}|=|\mathbf{u}\times\mathbf{v}|\)</span> as expected. We just found a geometric representation of the length of the cross product.</p>
<p>As just stated above, the vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> is orthogonal to the plane defined by <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. So, the resultant vector <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> of the cross product is orthogonal to both <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> as well. Ok, but we have two sides that <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> could aim at. Which side is the right one? In left-handed systems, it’s the one that makes <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> a left-handed system. While we don’t have a formal definition yet to establish if a set of three vectors composes a left-handed system, you can still identify the correct side.This is the side where <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> “sees” the first operand (in this case <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>) rotate clockwise toward the second operand <span class="math notranslate nohighlight">\((\mathbf{v})\)</span> with an angle of rotation <span class="math notranslate nohighlight">\(θ\)</span> in <span class="math notranslate nohighlight">\([0, \pi]\)</span>. Alternatively, you can also use your left hand: align your fingers with the direction of <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>, curl them towards <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, and your thumb will point in the direction of <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>.; this is called the left-hand-thumb rule. <br>
In right-handed systems, the correct side is the one that makes <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> a right-handed system.</p>
<figure class="align-default">
<img alt="../../../_images/cross-product2.png" src="../../../_images/cross-product2.png" />
</figure>
<p>The commutative property doesn’t apply <span class="math notranslate nohighlight">\((\mathbf{u}\times\mathbf{v}\ne\mathbf{v}\times\mathbf{u})\)</span> as if you swap the vectors <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> the direction of <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> changes as well (you can check it with the left-hand-thumb rule). However, you can easily verify that the following equivalence is true.</p>
<div class="math notranslate nohighlight">
\[\mathbf{u}\times\mathbf{v}=-(\mathbf{v}\times\mathbf{u})\]</div>
<p>And we also have that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
&amp;\mathbf{i}\ &amp;\times\ &amp;\mathbf{j} &amp;=\ &amp;\mathbf{k} \\
&amp;\mathbf{j}\ &amp;\times\ &amp;\mathbf{k} &amp;=\ &amp;\mathbf{i} \\
&amp;\mathbf{k}\ &amp;\times\ &amp;\mathbf{i} &amp;=\ &amp;\mathbf{j} \\
&amp;\mathbf{j}\ &amp;\times\ &amp;\mathbf{i} &amp;=\ &amp;\mathbf{-k} \\
&amp;\mathbf{k}\ &amp;\times\ &amp;\mathbf{j} &amp;=\ &amp;\mathbf{-i} \\
&amp;\mathbf{i}\ &amp;\times\ &amp;\mathbf{k} &amp;=\ &amp;\mathbf{-j} \\
&amp;\mathbf{i}\ &amp;\times\ &amp;\mathbf{i} &amp;=\ &amp;\mathbf{0} \\
&amp;\mathbf{j}\ &amp;\times\ &amp;\mathbf{j} &amp;=\ &amp;\mathbf{0} \\
&amp;\mathbf{k}\ &amp;\times\ &amp;\mathbf{k} &amp;=\ &amp;\mathbf{0}
&amp;\end{flalign} 
\end{split}\]</div>
<p>A way to remember the above equivalences is to consider the unit vectors <span class="math notranslate nohighlight">\(\{\mathbf{i},\mathbf{j},\mathbf{k}\}\)</span> as a circular sequence. If you cross multiply a vector by the next one, you get the third vector with a positive sign. Otherwise, you get a negative sign. Observe that if you cross multiply a vector by itself the result is the zero vector (or null vector, where all components are zero and the direction is undefined) as you can’t build a parallelogram with two equal vectors ─ you get a segment, so the area is zero.</p>
</section>
<section id="scalar-and-vector-triple-product">
<h4>Scalar and vector triple product<a class="headerlink" href="#scalar-and-vector-triple-product" title="Link to this heading">#</a></h4>
<p>The scalar triple product is nothing really new, as it simply combines the dot product and the cross product. It is defined as:</p>
<div class="math notranslate nohighlight">
\[V=\mathbf{u}\cdot(\mathbf{v}\times\mathbf{w})\]</div>
<p>where <span class="math notranslate nohighlight">\(V\)</span> represents the volume of the parallelepiped formed by the bound vectors <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>. Consider the following illustration.</p>
<figure class="align-default">
<img alt="../../../_images/triple-product.png" src="../../../_images/triple-product.png" />
</figure>
<p>As you know, the length of the cross product is the area of a parallelogram. Also, the volume of a parallelepiped is <span class="math notranslate nohighlight">\(V=b\times h\)</span>. Therefore, in order to compute the volume of the parallelepiped illustrated above, we can to write</p>
<div class="math notranslate nohighlight">
\[V=|\mathbf{u}| |\mathbf{v}\times\mathbf{w}|\cos{\theta}\]</div>
<p>with <span class="math notranslate nohighlight">\(|\mathbf{v}\times\mathbf{w}|=b\)</span> and <span class="math notranslate nohighlight">\(|\mathbf{u}|\cos{\theta}=h\)</span>.<br>
From equation <span class="math notranslate nohighlight">\((1)\)</span> we can also write it as</p>
<div class="math notranslate nohighlight">
\[V=\mathbf{u}\cdot (\mathbf{v}\times\mathbf{w})\]</div>
<p>which is the scalar triple product. If you expand it you have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
\mathbf{u}\cdot(\mathbf{v}\times\mathbf{w})&amp;=\mathbf{u}\cdot(v_yw_z-v_zw_y, v_zw_x-v_xw_z, v_xw_y-v_yw_x) \\
&amp;=u_x v_y w_z - u_x v_z w_y + u_y v_z w_x - u_y v_x w_z + u_z v_x w_y - u_z v_y w_x
\end{flalign}
\end{split}\]</div>
<p>which is exactly the determinant of the <span class="math notranslate nohighlight">\(3\times 3\)</span> matrix with <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> as columns, or rows. The upcoming appendix on matrices will provide further details of this result and illustrate how the scalar triple product can be used to determine if a set of three vectors forms a right-handed system. In brief, if the triple scalar product of three bound vectors defined in a right-handed system is positive, then they form a right-hand system.</p>
<p>We conclude this section pointing out that a vector triple product <span class="math notranslate nohighlight">\(\mathbf{a}\times(\mathbf{b}\times \mathbf{c})\)</span> also exists. However, we will only demonstrate the following identity, called the BAC-CAB identity.</p>
<div class="math notranslate nohighlight">
\[\mathbf{a}\times(\mathbf{b}\times\mathbf{c})=\mathbf{b}(\mathbf{a}\cdot\mathbf{c})-\mathbf{c}(\mathbf{a}\cdot\mathbf{b})\]</div>
<div class="dropdown admonition">
<p class="admonition-title">Proof</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
\mathbf{a}\times (\mathbf{b}\times\mathbf{c})&amp;=(a_x, a_y, a_z)\times [(b_x, b_y, b_z)\times (c_x, c_y, c_z)] \\
&amp;=(a_x,\, a_y,\, a_z)\times (b_yc_z-b_zc_y,\; b_zc_x-b_xc_z,\; b_xc_y-b_yc_x) \\
&amp;=\big({\color{#FF6666}{a_y (b_xc_y-b_yc_x)-a_z (b_zc_x-b_xc_z)}},\\ &amp;\quad\quad\quad\quad{\color{#44FF66}{a_z (b_yc_z-b_zc_y)-a_x\ (b_xc_y-b_yc_x)}},\\ &amp;\quad\quad\quad\quad\quad\quad{\color{#44AAFF}{a_x (b_zc_x-b_xc_z)-a_y(b_yc_z-b_zc_y)}}\big)
\end{flalign}
\end{split}\]</div>
<p>Below, you can observe that the first component of <span class="math notranslate nohighlight">\(\mathbf{b}(\mathbf{a}\cdot\mathbf{c})-\mathbf{c}(\mathbf{a}\cdot\mathbf{b})\)</span> (the one highlighted in red) is equivalent to the first component of <span class="math notranslate nohighlight">\(\mathbf{a}\times(\mathbf{b}\times\mathbf{c})\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{flalign}
(\mathbf{b}(\mathbf{a}\cdot\mathbf{c})-\mathbf{c}(\mathbf{a}\cdot\mathbf{b}))_x &amp;= b_x (a_xc_x+a_yc_y+a_zc_z)-c_x (a_xb_x+a_yb_y+a_zb_z) \\
&amp;=a_xb_xc_x+a_yb_xc_y+a_zb_xc_z-a_xb_xc_x-a_yb_yc_x-a_zb_zc_x \\
&amp;={\color{#FF6666}{a_y (b_xc_y-b_yc_x)-a_z (b_zc_x-b_xc_z)}}
\end{flalign}
\end{split}\]</div>
<p>The same applies to the other two components.</p>
</div>
<br>
</section>
</section>
</section>
<section id="vectors-in-directx">
<h2>Vectors in DirectX<a class="headerlink" href="#vectors-in-directx" title="Link to this heading">#</a></h2>
<p>Vectors play a crucial role in computer graphics, making them a fundamental tool to use in DirectX applications as well. They are widely used in both C++ and in HLSL.</p>
<section id="hlsl">
<h3>HLSL<a class="headerlink" href="#hlsl" title="Link to this heading">#</a></h3>
<p>In HLSL, vectors of two, three and four floating-point components are represented by the built-in types <strong>float2</strong>, <strong>float3</strong> and <strong>float4</strong>, respectively. For vectors of signed integers, we use <strong>int2</strong>, <strong>int3</strong> and <strong>int4</strong> ─ the unsigned version can be specified by replacing the prefix <strong>i</strong> with <strong>u</strong>. Alternatively, we can use the keyword <strong>vector</strong> to declare vectors by using a template syntax to specify number and type of the components.</p>
<p>The shader model defines 128-bit shader core registers to hold both integer and floating-point vectors to perform SIMD operations (more on this shortly).</p>
<p>The components of a vector can be accessed using the subscript operator, [ ], to provide array indexing. Alternatively, one of the following naming sets can be used:</p>
<ul class="simple">
<li><p>The position set:  <span class="math notranslate nohighlight">\(\ x,y,z,w\)</span><br></p></li>
<li><p>The color set: <span class="math notranslate nohighlight">\(\ r,g,b,a\)</span></p></li>
</ul>
<p>Specifying one or more vector components is called swizzling. For example:</p>
<br>
<div class="highlight-hlsl notranslate"><div class="highlight"><pre><span></span><span class="kt">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                             </span><span class="c1">// int iVector = 1;</span>
<span class="kt">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">0.4</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">};</span><span class="w">      </span><span class="c1">// float4 dVector = { 0.2, 0.3, 0.4, 0.5 };  </span>
<span class="w">  </span>
<span class="kt">float4</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">};</span>
<span class="kt">float</span><span class="w"> </span><span class="n">f0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">         </span><span class="c1">// f0 = 1.0f</span>
<span class="kt">float</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">g</span><span class="p">;</span><span class="w">         </span><span class="c1">// f1 = 2.0f</span>
<span class="kt">float</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">        </span><span class="c1">// f2 = 3.0f</span>
<span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">;</span><span class="w">             </span><span class="c1">// u = (1.0f, 2.0f, 3.0f, 4.0f)</span>
<span class="w"> </span>
<span class="kt">float4</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0f</span><span class="w"> </span><span class="p">};</span>
<span class="kt">float3</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span><span class="w">            </span><span class="c1">// vec1 = (1.0f, 2.0f, 3.0f)</span>
<span class="kt">float2</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">rb</span><span class="p">;</span><span class="w">             </span><span class="c1">// vec2 = (1.0f, 3.0f)</span>
<span class="kt">float4</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">zzxy</span><span class="p">;</span><span class="w">           </span><span class="c1">// vec3 = (3.0f, 3.0f, 1.0f, 2.0f)</span>
<span class="n">vec3</span><span class="p">.</span><span class="n">wxyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">;</span><span class="w">               </span><span class="c1">// vec3 = (3.0f, 1.0f, 2.0f, 3.0f)</span>
<span class="n">vec3</span><span class="p">.</span><span class="n">yw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec1</span><span class="p">.</span><span class="n">zz</span><span class="p">;</span><span class="w">              </span><span class="c1">// vec3 = (3.0f, 3.0f, 2.0f, 3.0f)</span>
<span class="w"> </span>
<span class="kt">float4</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float4</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// w = (1.0f, 2.0f, 3.0f, 5.0f)</span>
</pre></div>
</div>
</section>
<section id="c">
<h3>C++<a class="headerlink" href="#c" title="Link to this heading">#</a></h3>
<p>Using vectors in C++ is not as straightforward as in HLSL because there are no built-in types available. However, the <strong>XMVECTOR</strong> type, defined in the <em>DirectXMath.h</em> header file provided by the DirectX math API (DirectXMath), allows us to create variables that map to 128-bit CPU registers.</p>
<div class="literal-block-wrapper docutils container" id="vectors-xmvector-code">
<div class="code-block-caption"><span class="caption-text">DirectXMath.h</span><a class="headerlink" href="#vectors-xmvector-code" title="Link to this code">#</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kr">__m128</span><span class="w"> </span><span class="n">XMVECTOR</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>That is, a variable of type <strong>__m128</strong> is backed by a memory region of 128 bits that the compiler can use as a source\destination to load\store data in\from XMM[0-7] registers, which are used in SIMD instructions. SIMD (single instruction multiple data) allows us to perform more operations with a single instruction. To better understand how SIMD works, it’s useful to consider a practical example. First, it is worth noting that in DirectX it is common to use vectors of four components, where each of them is a 4-byte floating point or integer value.</p>
<blockquote>
<div><p>You may wonder why we have vectors of four components if we mostly work in 3D space (where only 3 coordinates are needed). Well, as we will see in a later tutorial, at some point we will introduce an extra coordinate to distinguish between free vectors and bound vectors. That is, we will work in a special homogeneous coordinate system to use both points and vectors.</p>
</div></blockquote>
<p>Now consider the following sum of vectors, which means four sums of the corresponding components.</p>
<br>
<p><span class="math notranslate nohighlight">\(\mathbf{u}+\mathbf{v}=(u_x+v_x,\ u_y+v_y,\ u_z+v_z,\ u_w+v_w)\)</span></p>
<br>
<p>With SIMD we can perform the four sums in a single instruction. In general, the math API of DirectX, called DirectXMath, takes advantage of SIMD to let the CPU perform four operations (OPs) in a single instruction. That is, DirectXMath can use SIMD instructions to perform the same operation on the corresponding components of a couple of <strong>XMVECTOR</strong>s used as operands\sources, as shown in the following illustration.</p>
<br>
<p><img alt="Image" src="Tutorials/Appendices/01-MathBasics/images/A/01/SIMD.jpg" /></p>
<br>
<p>The only problem is that <strong>__m128</strong> variables need to be aligned on 16-byte boundaries in memory. That’s not really an issue if you declare a global or local variable of this type because the compiler will automatically align them. Problems arise when you use a <strong>XMVECTOR</strong> (which is an alias for <strong>__m128</strong>) as a member of a structure or a class, where the C++ packing rules can misalign it. For this purpose, DirectXMath provides the following types, which allow us to use integer or floating-point vectors as class members.</p>
<br>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 32-bit signed floating-point components</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">XMFLOAT2</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="w"> </span>
<span class="w"> </span>
<span class="k">struct</span><span class="w"> </span><span class="nc">XMFLOAT3</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
<span class="w"> </span>
<span class="w"> </span>
<span class="k">struct</span><span class="w"> </span><span class="nc">XMFLOAT4</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<br>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 32-bit signed integer components</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">XMINTT2</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="w"> </span>
<span class="w"> </span>
<span class="k">struct</span><span class="w"> </span><span class="nc">XMINT3</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
<span class="w"> </span>
<span class="w"> </span>
<span class="k">struct</span><span class="w"> </span><span class="nc">XMINT4</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<br>
<p>These types can be used without worrying about alignment issues. However, we can’t take advantage of SIMD if you use them, as they don’t map to XMM registers. So, you must remember to convert to <strong>XMVECTOR</strong> before performing any calculations on vectors. DirectXMath also provides some helper functions to convert from <strong>XMFLOAT</strong> to <strong>XMVECTOR</strong>.</p>
<br>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XMVECTOR</span><span class="w"> </span><span class="nf">XMLoadFloat2</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">XMFLOAT2</span><span class="o">*</span><span class="w"> </span><span class="n">pSource</span><span class="p">);</span>
<span class="w"> </span>
<span class="n">XMVECTOR</span><span class="w"> </span><span class="nf">XMLoadFloat3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">XMFLOAT3</span><span class="o">*</span><span class="w"> </span><span class="n">pSource</span><span class="p">);</span>
<span class="w"> </span>
<span class="n">XMVECTOR</span><span class="w"> </span><span class="nf">XMLoadFloat4</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">XMFLOAT4</span><span class="o">*</span><span class="w"> </span><span class="n">pSource</span><span class="p">);</span>
</pre></div>
</div>
<br>
<p>And back from <strong>XMVECTOR</strong> to <strong>XMFLOAT</strong> (similar functions are defined for <strong>XMINT</strong> as well).</p>
<br>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">XMStoreFloat2</span><span class="p">(</span><span class="n">XMFLOAT2</span><span class="o">*</span><span class="w"> </span><span class="n">pDestination</span><span class="p">,</span><span class="w"> </span><span class="n">FXMVECTOR</span><span class="w">  </span><span class="n">V</span><span class="p">);</span>
<span class="w"> </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">XMStoreFloat3</span><span class="p">(</span><span class="n">XMFLOAT3</span><span class="o">*</span><span class="w"> </span><span class="n">pDestination</span><span class="p">,</span><span class="w"> </span><span class="n">FXMVECTOR</span><span class="w">  </span><span class="n">V</span><span class="p">);</span>
<span class="w"> </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">XMStoreFloat4</span><span class="p">(</span><span class="n">XMFLOAT4</span><span class="o">*</span><span class="w"> </span><span class="n">pDestination</span><span class="p">,</span><span class="w"> </span><span class="n">FXMVECTOR</span><span class="w">  </span><span class="n">V</span><span class="p">);</span>
</pre></div>
</div>
<br>
<p>If a function takes one or more <strong>XMVECTOR</strong>s as parameters then:</p>
<ul class="simple">
<li><p><strong>FXMVECTOR</strong> must be used for the first three parameters.</p></li>
<li><p><strong>GXMVECTOR</strong> must be used for the fourth parameter.</p></li>
<li><p><strong>HXMVECTOR</strong> must be used for the remaining ones.</p></li>
</ul>
<br>
<p>This allows to use the appropriate calling conventions for each platform supported by the DirectXMath Library. To learn more about calling convections you can refer to the official documentation (see [3] and [4] in the reference list at the end of the tutorial).</p>
<p>As stated above, <strong>XMVECTOR</strong> is just an alias for <strong>__m128</strong>, which identify a type mapped to XMM registers. This means we should not use <strong>XMVECTOR</strong> to operate with vectors without using SIMD instructions. For this reason, DirectXMath provides many helper functions that take advantage of SIMD to initialize <strong>XMVECTOR</strong>s and operate with them. We will examine most of these functions in the upcoming tutorials.</p>
<p>If you want to declare a vectorized-constant (const <strong>XMVECTOR</strong>) then it is recommended to use <strong>XMVECTORF32</strong> for floating-point values, and <strong>XMVECTORU32</strong> (or <strong>XMVECTORI32</strong>) for integer values. That’s because these types are defined as the union of a <strong>XMVECTOR</strong> and an array. This allows us to use the initialization syntax, and let the compiler use SIMD instructions for other operations.</p>
<br>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">__declspec</span><span class="p">(</span><span class="n">align</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">XMVECTORF32</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">union</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="n">XMVECTOR</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w"> </span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="n">XMVECTOR</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="w"> </span>
<span class="w"> </span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">XMVECTORF32</span><span class="w"> </span><span class="n">vZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>[WIP]</p>
<br>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Tutorials\Appendices\01-MathBasics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="math-basics.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Math Basics</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coordinate-systems">Coordinate systems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#d-coordinate-system">1D Coordinate system</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cartesian-coordinate-system">Cartesian coordinate system</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#polar-coordinate-system">Polar coordinate system</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cylindrical-and-spherical-coordinate-systems">Cylindrical and spherical coordinate systems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#homogeneous-coordinate-system">Homogeneous coordinate system</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Vectors</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#definition">Definition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-operations">Basic operations</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#addition-and-subtraction">Addition and Subtraction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#scalar-multiplication">Scalar multiplication</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#properties-of-addition-and-scalar-multiplication">Properties of addition and scalar multiplication</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#length-of-a-vector">Length of a vector</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dot-product">Dot product</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#properties-of-dot-multiplication">Properties of dot multiplication</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#orthogonal-projection">Orthogonal projection</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#gram-schmidt-orthogonalization">Gram-Schmidt Orthogonalization</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cross-product">Cross product</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#scalar-and-vector-triple-product">Scalar and vector triple product</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vectors-in-directx">Vectors in DirectX</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hlsl">HLSL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#c">C++</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By P. A. Minerva
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>