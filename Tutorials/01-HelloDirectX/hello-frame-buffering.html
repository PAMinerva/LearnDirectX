
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Hello Frame Buffering &#8212; Learn DirectX</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=bd9e20870c6007c4c509"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=afe5de03"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Tutorials/01-HelloDirectX/hello-frame-buffering';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="Hello Texture" href="hello-texture.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <header>


  <div class="bd-header-announcement container-fluid bd-header-announcement">
    <div class="bd-header-announcement__content">🚧 This documentation is a work in progress! 🚧</div>
  </div>

  
    <div class="bd-header navbar navbar-expand-lg bd-navbar">
    </div>
  
  </header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../presentation.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Learn DirectX - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Learn DirectX - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../presentation.html">
                    Welcome to Learn DirectX
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../00-Intro/intro-and-prerequisites.html">Introduction and Prerequisites</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Hello DirectX</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="hello-world.html">Hello World</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="hello-window.html">Hello Window</a></li>
<li class="toctree-l2"><a class="reference internal" href="hello-triangle.html">Hello Triangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="hello-bundles.html">Hello Bundles</a></li>
<li class="toctree-l2"><a class="reference internal" href="hello-cbs.html">Hello Constant Buffers</a></li>
<li class="toctree-l2"><a class="reference internal" href="hello-texture.html">Hello Texture</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Hello Frame Buffering</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/PAMinerva/LearnDirectX" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/PAMinerva/LearnDirectX/issues/new?title=Issue%20on%20page%20%2FTutorials/01-HelloDirectX/hello-frame-buffering.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/Tutorials/01-HelloDirectX/hello-frame-buffering.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Hello Frame Buffering</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cpu-gpu-parallelism">CPU-GPU parallelism</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#d3d12helloframebuffering-code-review">D3D12HelloFrameBuffering: code review</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">Source Code</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="hello-frame-buffering">
<h1>Hello Frame Buffering<a class="headerlink" href="#hello-frame-buffering" title="Link to this heading">#</a></h1>
<br>
<figure class="align-default">
<img alt="../../_images/HelloFrameBuffering.png" src="../../_images/HelloFrameBuffering.png" />
</figure>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>In previous tutorials, we used CPU and GPU in a sequential, suboptimal way. Indeed, we used a single command allocator to record drawing commands for two buffers in the swap chain. This means that, to avoid overwriting commands still in use by the GPU, we had to flush the command queue before recording new commands for creating the next frame – since all commands were recorded in the same memory location. This resulted in a sequential workflow: the CPU recorded the commands to create a frame and waited for the GPU to complete the actual rendering work. In other words, we were not able to create frames in advance on the CPU timeline with respect to the GPU. This tutorial addresses the problem by introducing a separate command allocator for each buffer in the swap chain.</p>
<p>The sample we will review in this tutorial (<a class="reference external" href="https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/Samples/Desktop/D3D12HelloWorld">D3D12HelloFrameBuffering</a>) is not much different from the samples we examined so far, as it simply shows a triangle on the screen (I changed the background color of the screenshot above to visually distinguish it from the screenshots of previous tutorials). However, for the first time, we will take advantage of the parallelism between CPU and GPU by creating frames in advance on the CPU timeline.</p>
<br>
</section>
<section id="cpu-gpu-parallelism">
<h2>CPU-GPU parallelism<a class="headerlink" href="#cpu-gpu-parallelism" title="Link to this heading">#</a></h2>
<p>Before discussing how to unleash parallelism between CPU and GPU, it can be useful to revisit the explanation provided in a previous tutorial regarding frame presentation, which is replicated below for convenience.</p>
<div class="seealso admonition">
<p class="admonition-title">from <a class="reference internal" href="hello-window.html"><span class="std std-doc">Hello Window</span></a></p>
<p><strong>IDXGISwapChain::Present</strong> allows presenting (to the user, on the screen) the frame just created on the CPU timeline (using the current back buffer as the render target). How does it work? Present operations occur on the graphics queue associated with the swap chain. That is, when you call <strong>Present</strong>, a present operation is recorded in the command queue associated with swap chain during its creation, and a request to present the frame is inserted in a queue called the present queue, waiting for the GPU to execute the commands to draw on the related back buffer. Since this happens only after recording all the commands needed to create the frame, you are sure the GPU reached the present operation in the command queue only at the very end (i.e., after executing all the other previous drawing commands). At that point, the frame associated with the request in the present queue is done, ready to be shown on the screen at the next vertical interval when the swap/flip between the back and present buffers takes place.</p>
<figure class="align-default">
<img alt="../../_images/rect853d.png" src="../../_images/rect853d.png" />
</figure>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>When you create a frame and present it on the CPU timeline, nothing happens on the related back buffer until the GPU starts executing drawing commands in the related command list.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Present</strong> also updates the index of the current back buffer in the swap chain so that the next frame will be created on the other buffer when it becomes available again as a render target.</p>
</div>
<p>Observe that <strong>Present</strong> takes, as its first parameter (called <em>SyncInterval</em>), a value that specifies how to synchronize the presentation of a frame with the vertical blank. For values greater than zero, it indicates the number of vertical intervals the frame waits in the present queue before getting ready to be presented on the screen, enabling v-sync. In this sample, we always pass 1 as an argument to this parameter to specify that we want to wait a single vertical interval. In a later tutorial, we will explore what it means if you pass 0 to this parameter.</p>
</div>
<p>While this explanation provides a basic understanding on frame presentation, it offers an oversimplified view of how frames are actually presented on the screen. Indeed, when a frame is presented, various factors can affect the presentation process, which depends on the presentation model (specified in the swap chain), window mode (full screen or windowed), and V-Sync settings (on or off). However, exploring every possible combination is beyond the scope of this tutorial. Therefore, I will focus on explaining what happens in the <strong>D3D12HelloFrameBuffering</strong> sample (and previous ones as well), where we create a swap chain that uses the flip model to present frames on the screen, with a window that cannot be switched to full screen, and V-Sync enabled (that is, when we pass 1 to <em>SyncInterval</em>). Other combinations will be covered in later tutorials.</p>
<p>By specifying the flag <strong>DXGI_SWAP_EFFECT_FLIP_DISCARD</strong> during swap chain creation, we indicate our intention to use the flip model to present frames on the screen. When this model is employed with windowed applications (i.e., not full screen), a system service called the <strong>Desktop Window Manager</strong> (DWM) wakes up at every vertical blank and retrieves the latest completed back buffer in the swap chain of all graphics applications running on the desktop (including the offscreen buffers of all “normal” windowed applications). It then composes the final image of the entire desktop into its own back buffer, which will be displayed on the screen at the next vertical interval, when it becomes the present buffer.</p>
<figure class="align-default">
<img alt="../../_images/dwm.png" src="../../_images/dwm.png" />
</figure>
<figure class="align-default">
<img alt="../../_images/dwm-composition.png" src="../../_images/dwm-composition.png" />
</figure>
<p>Let’s use a practical example to explain in more detail what happens in the <strong>D3D12HelloFrameBuffering</strong> sample under the conditions outlined above, where the flip model is used with a swap chain that includes two buffers for rendering in an application running in windowed mode. This will also allow us to illustrate how to unlock parallelism between CPU and GPU. For convenience, we’ll refer to the two buffers in the swap chain as A and B.</p>
<p>As soon as we start the application, the commands to draw the very first frame on buffer A are recorded in a command list. Then, <strong>ExecuteCommandLists</strong> and <strong>Present</strong> are invoked to send the command list to the command queue and insert the first frame into the present queue, respectively. As a consequence, a present operation is also added to the command queue after the command list.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Until now, we have only created the frame on the CPU timeline. By recording drawing commands in a command list and calling <strong>Present</strong>, we have simply submitted instructions to the GPU. The actual rendering process on the associated back buffer will not begin until the GPU starts executing those commands from the command queue.</p>
</div>
<p>Provided that we don’t overwrite the memory space managed by the command allocator for the command list operating on buffer A (e.g., using a new allocator for the command list operating on buffer B), we can start creating (on the CPU timeline) the second frame with buffer B as the render target. We can queue this new frame with the confidence that the GPU won’t write onto buffer B before it finishes drawing on buffer A, or if buffer B is unavailable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When command lists are submitted to the same command queue through separate calls to <strong>ExecuteCommandLists</strong>, strict sequential execution is guaranteed. This means that the GPU processes them in the same order they were submitted, ensuring each command list completes before the next one begins. <br>
However, submitting multiple command lists together within a single <strong>ExecuteCommandLists</strong> call provides weaker ordering guarantees. The GPU typically start execution in submission order, but it may not necessarily finish them in the same order. It is free to start processing new command lists (in parallel) even before older ones have completed.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A buffer is said to be available if there are no outstanding present operations that reference it, and it is currently not being displayed by the system. Otherwise, it is unavailable.<br>
A frame is considered ready to be shown on the screen when the GPU met the related present operation in the command queue, and if the synchronization time associated with the presentation of the frame in the present queue expired.<br>
A frame is retired from the present queue if discarded by the DWM (more on this shortly), or when replaced by a new frame as the one displayed on the screen.</p>
</div>
<p>At this point, we need a mechanism to know when buffers A and B can be reused as render targets to create new frames. Fences effectively serve this purpose. By appending a fence after each command list submitted to the command queue, we can synchronize CPU and GPU operations. Concretely, the CPU waits for the GPU to signal a fence before creating a new frame. This guarantees that no pending commands remain in at least one of the submitted command lists (or rather, in the corresponding memory space managed by the command allocator). Consequently, we can confidently create and present new frames as long as the present queue has sufficient space to accommodate new frames (default is three slots, adjustable as needed) and provided that the back buffer we want to use as the render target is available. Otherwise, a <strong>Present</strong> call will block until a frame is retired from the present queue, which makes the back buffer available again for reuse and creates space in the present queue for a new frame.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>While creating as many frames as possible in advance on the CPU timeline may seem like a good idea, this approach has a downside. Specifically, creating too many frames in advance can increase present or frame latency, the time it takes for a frame to be displayed on the screen after it has been created on the CPU timeline. This means that there is a trade-off between reducing idle time (for both the CPU and GPU) by creating frames in advance and minimizing frame latency to ensure a responsive and smooth user experience. It is important to carefully balance these two factors to achieve optimal performance and efficiency in our applications.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because we usually send command lists to the command queue (with <strong>ExecuteCommandLists</strong>) before calling <strong>Present</strong>, the rendering work of the GPU could be paused\queued, and resume once the back buffer is available (when the frame that used the back buffer as render target is retired from the present queue).</p>
</div>
<p>Regardless of how many frames are presented (on the CPU timeline) and completed (on the GPU timeline), at the next vertical interval the DWM wakes up and gets the latest completed frame to start composing the entire desktop. In the <strong>D3D12HelloFrameBuffering</strong> sample, composition involves copying the latest completed swap chain back buffer to the DWM’s back buffer, which is then sent to the display hardware at the next vertical interval as the actual present buffer. After this copy operation, the frame is considered queued and then finally displayed when the hardware is ready to do it. Once a new frame is queued, the displayed one, along with others that missed the chance to be presented on the screen due to a newer completed frame being available for the DWM, can be retired from the present queue. Note that, in this scenario, the actual flip happens between the back and present buffers of the DWM.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As mentioned earlier, when command lists are submitted through separate calls to ExecuteCommandLists, they are processed and completed in order. In this scenario, if a frame in the present queue is retired because a newer completed frame is available for the DWM, we can be confident that that the corresponding command list has already been executed. Consequently, we are free to overwrite the memory space holding the related commands, and the GPU can reuse the associated back buffer for subsequent drawing operations. <br>
Command lists are the only resource requiring explicit synchronization (using fences) during presentation. On the other hand, swap chain buffers are automatically synchronized by the API and the driver for presentation purposes. Nevertheless, we still need to synchronize render targets with resource transitions for rendering purposes.</p>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The note above refers to resource synchronization during presentation and rendering. However, during frame creation on the CPU timeline, we still need to preserve\synchronize all the GPU resources (buffers, descriptors, synchronization objects, etc.) that our application accesses with write operations to create a frame. For this purpose, we can, for example, provide multiple copies of those resources (one for each frame we want to create in advance on the CPU timeline). This way, frame creation won’t interfere with other pending frames in GPU queues because resources that will be used on the GPU timeline to render pending frames are preserved during the creation of new frames on the CPU timeline that access the same resources.</p>
</div>
<p>Coming back to our example, we can start creating a new frame on the CPU timeline (the third, with buffer A as the render target) once the fence gets signaled the first time. Indeed, at that point, we can be sure that the GPU has finished executing the command list for the first frame, which also used buffer A. Observe that, if the first frame in the present queue hasn’t been displayed yet, the subsequent call to <strong>Present</strong> (used to present the third frame) will block until the first frame is retired from the present queue. In this scenario, it is possible to have two frames in the present queue (both the first using buffer A and the second using buffer B). If the GPU is fast enough to complete both of them before the next vertical blank, the DWM will select the second frame (the last completed one) while the first one is immediately retired from the present queue. Since the GPU has undoubtedly executed the command lists of both the first two frames, we would eventually be able to create the third frame on the CPU timeline with A as the render target and present it. Indeed, once the first frame becomes retired, the <strong>Present</strong> waiting on the CPU timeline can unblock to queue the third frame, and the GPU can execute the corresponding command list. After this third frame becomes queued, the second one can be retired from the present queue. And so on.</p>
<p>Unfortunately, the assistance provided by the DWM in the presentation process comes at a cost. It introduces a presentation latency of a bit more than a vertical interval, at least (but it can be more). The DWM takes one vertical interval to compose the desktop image, and this needs to be added to the time the GPU requires to complete the frame. However, things can worsen when v-sync is on, as illustrated in the image below. In that case, you need to add at least another vertical interval to the presentation latency because each frame has to wait for the synchronization time associated with its presentation before becoming ready. This means that the composition using a frame just completed will be the one executed by the DWM woken up at the next v-sync ─ that is, the frame misses a composition.</p>
<figure class="align-default">
<img alt="../../_images/v-sync-on.png" src="../../_images/v-sync-on.png" />
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As mentioned at the beginning of the tutorial, the <strong>Present</strong> function takes, as its first parameter, a value that specifies how to synchronize the presentation of a frame with the vertical blank. We already know what happens by passing 1 or greater values. On the other hand, by passing 0 the remaining time on the previously presented frame in the present queue will be cancelled, while the frame you are presenting will be discarded if a newer one becomes queued.</p>
</div>
<p>In conclusion, we can state that by using a different command allocator for each buffer in the swap chain and employing a fence after each command list in the command queue for synchronization purposes, we can create frames in advance on the CPU timeline, unleashing parallelism between the CPU and GPU. However, remember that creating frames too far in advance can result in noticeable present latency. Furthermore, preserving the state of all GPU resources modified during frame creation on the CPU timeline is also essential for correct rendering.</p>
<br>
</section>
<section id="d3d12helloframebuffering-code-review">
<h2>D3D12HelloFrameBuffering: code review<a class="headerlink" href="#d3d12helloframebuffering-code-review" title="Link to this heading">#</a></h2>
<p>Now, we are ready to review the code of the sample. Let’s start with the application class.</p>
<div class="literal-block-wrapper docutils container" id="helloframebuffering-d3d12helloframebuffering-code">
<div class="code-block-caption"><span class="caption-text">D3D12HelloFrameBuffering/D3D12HelloFrameBuffering.h</span><a class="headerlink" href="#helloframebuffering-d3d12helloframebuffering-code" title="Link to this code">#</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">D3D12HelloFrameBuffering</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DXSample</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">D3D12HelloFrameBuffering</span><span class="p">(</span><span class="n">UINT</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">UINT</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w"> </span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnInit</span><span class="p">();</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnUpdate</span><span class="p">();</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnRender</span><span class="p">();</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnDestroy</span><span class="p">();</span>
<span class="w"> </span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// In this sample we overload the meaning of FrameCount to mean both the maximum</span>
<span class="w">    </span><span class="c1">// number of frames that will be queued to the GPU at a time, as well as the number</span>
<span class="w">    </span><span class="c1">// of back buffers in the DXGI swap chain. For the majority of applications, this</span>
<span class="w">    </span><span class="c1">// is convenient and works well. However, there will be certain cases where an</span>
<span class="w">    </span><span class="c1">// application may want to queue up more frames than there are back buffers</span>
<span class="w">    </span><span class="c1">// available.</span>
<span class="w">    </span><span class="c1">// It should be noted that excessive buffering of frames dependent on user input</span>
<span class="w">    </span><span class="c1">// may result in noticeable latency in your app.</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UINT</span><span class="w"> </span><span class="n">FrameCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Vertex</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">XMFLOAT3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">        </span><span class="n">XMFLOAT4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Pipeline objects.</span>
<span class="w">    </span><span class="n">CD3DX12_VIEWPORT</span><span class="w"> </span><span class="n">m_viewport</span><span class="p">;</span>
<span class="w">    </span><span class="n">CD3DX12_RECT</span><span class="w"> </span><span class="n">m_scissorRect</span><span class="p">;</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDXGISwapChain3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_swapChain</span><span class="p">;</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12Device</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_device</span><span class="p">;</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_renderTargets</span><span class="p">[</span><span class="n">FrameCount</span><span class="p">];</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12CommandAllocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_commandAllocators</span><span class="p">[</span><span class="n">FrameCount</span><span class="p">];</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12CommandQueue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_commandQueue</span><span class="p">;</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12RootSignature</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_rootSignature</span><span class="p">;</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12DescriptorHeap</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_rtvHeap</span><span class="p">;</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12PipelineState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_pipelineState</span><span class="p">;</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12GraphicsCommandList</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_commandList</span><span class="p">;</span>
<span class="w">    </span><span class="n">UINT</span><span class="w"> </span><span class="n">m_rtvDescriptorSize</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// App resources.</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_vertexBuffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">D3D12_VERTEX_BUFFER_VIEW</span><span class="w"> </span><span class="n">m_vertexBufferView</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Synchronization objects.</span>
<span class="w">    </span><span class="n">UINT</span><span class="w"> </span><span class="n">m_frameIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">HANDLE</span><span class="w"> </span><span class="n">m_fenceEvent</span><span class="p">;</span>
<span class="w">    </span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12Fence</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_fence</span><span class="p">;</span>
<span class="w">    </span><span class="n">UINT64</span><span class="w"> </span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">FrameCount</span><span class="p">];</span>
<span class="w"> </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">LoadPipeline</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">LoadAssets</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">PopulateCommandList</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">MoveToNextFrame</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">WaitForGpu</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>At this point, the comment on the <strong>FrameCount</strong> variable should be clear: if you keep creating frames in advance on the CPU timeline, at some point either the CPU (after the call to <strong>Present</strong>) or the GPU (during the rendering work) will end up waiting for a back buffer to become available again, increasing the present latency. <br>
In this sample, we need two command allocators because we are going to queue two frames to the GPU before waiting on the CPU timeline. As you know, we can reuse the same command list object, provided that we don’t overwrite the memory holding the corresponding commands if they have not yet been executed by the GPU. <br>
As explained earlier, we need to preserve GPU resources accessed with write operations during frame creation on the CPU timeline. This is why we also need two different fence values to delimit (in the command queue) the command lists of the two frames we want to queue. This way, we can be notified when the GPU finishes drawing one of them, so that we can resume creating frames on the CPU timeline. <br>
We will use <strong>WaitForGPU</strong> to flush the command queue. On the other hand, <strong>MoveToNextFrame</strong> only waits until the GPU finishes drawing at least one (the oldest) of the two queued frames. In other words, it checks if we can continue creating frames on the CPU timeline.</p>
<p>The <strong>LoadPipeline</strong> function now creates two command allocators, so the call to the <strong>CreateCommandAllocator</strong> function has been placed inside a for loop.</p>
<div class="literal-block-wrapper docutils container" id="helloframebuffering-loadpipeline-code">
<div class="code-block-caption"><span class="caption-text">D3D12HelloFrameBuffering/D3D12HelloFrameBuffering.cpp</span><a class="headerlink" href="#helloframebuffering-loadpipeline-code" title="Link to this code">#</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Load the rendering pipeline dependencies.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">D3D12HelloFrameBuffering::LoadPipeline</span><span class="p">()</span>
<span class="p">{</span>

<span class="w">    </span><span class="c1">// ...</span>

<span class="w"> </span>
<span class="w">    </span><span class="c1">// Create frame resources.</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CD3DX12_CPU_DESCRIPTOR_HANDLE</span><span class="w"> </span><span class="n">rtvHandle</span><span class="p">(</span><span class="n">m_rtvHeap</span><span class="o">-&gt;</span><span class="n">GetCPUDescriptorHandleForHeapStart</span><span class="p">());</span>
<span class="w"> </span>
<span class="w">        </span><span class="c1">// Create a RTV and a command allocator for each frame.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">UINT</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FrameCount</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">m_swapChain</span><span class="o">-&gt;</span><span class="n">GetBuffer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_renderTargets</span><span class="p">[</span><span class="n">n</span><span class="p">])));</span>
<span class="w">            </span><span class="n">m_device</span><span class="o">-&gt;</span><span class="n">CreateRenderTargetView</span><span class="p">(</span><span class="n">m_renderTargets</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Get</span><span class="p">(),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">rtvHandle</span><span class="p">);</span>
<span class="w">            </span><span class="n">rtvHandle</span><span class="p">.</span><span class="n">Offset</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtvDescriptorSize</span><span class="p">);</span>
<span class="w"> </span>
<span class="w">            </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">m_device</span><span class="o">-&gt;</span><span class="n">CreateCommandAllocator</span><span class="p">(</span><span class="n">D3D12_COMMAND_LIST_TYPE_DIRECT</span><span class="p">,</span><span class="w"> </span><span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_commandAllocators</span><span class="p">[</span><span class="n">n</span><span class="p">])));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Now, let’s see what’s new in <strong>LoadAssets</strong>.</p>
<div class="literal-block-wrapper docutils container" id="helloframebuffering-loadassets-code">
<div class="code-block-caption"><span class="caption-text">D3D12HelloFrameBuffering/D3D12HelloFrameBuffering.cpp</span><a class="headerlink" href="#helloframebuffering-loadassets-code" title="Link to this code">#</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Load the sample assets.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">D3D12HelloFrameBuffering::LoadAssets</span><span class="p">()</span>
<span class="p">{</span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Create synchronization objects and wait until assets have been uploaded to the GPU.</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">m_device</span><span class="o">-&gt;</span><span class="n">CreateFence</span><span class="p">(</span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">],</span><span class="w"> </span><span class="n">D3D12_FENCE_FLAG_NONE</span><span class="p">,</span><span class="w"> </span><span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_fence</span><span class="p">)));</span>
<span class="w">        </span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">        </span><span class="c1">// Create an event handle to use for frame synchronization.</span>
<span class="w">        </span><span class="n">m_fenceEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateEvent</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_fenceEvent</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">HRESULT_FROM_WIN32</span><span class="p">(</span><span class="n">GetLastError</span><span class="p">()));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w"> </span>
<span class="w">        </span><span class="c1">// Wait for the command list to execute; we are reusing the same command </span>
<span class="w">        </span><span class="c1">// list in our main loop but for now, we just want to wait for setup to </span>
<span class="w">        </span><span class="c1">// complete before continuing.</span>
<span class="w">        </span><span class="n">WaitForGpu</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>First, we create a fence with a value of 0 ─ <strong>m_fenceValues</strong> is initalized to <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">0}</span></code> in the constructor of the <strong>D3D12HelloFrameBuffering</strong> class (refer to the complete source code of the sample). Next, we increment the value of the fence used to delimit the command list for the initialization phase. This will allow us to distinguish between different command lists in the command queue. Finally, we create an event and call the <strong>WaitForGpu</strong> function to flush the command queue after the initialization phase.</p>
<div class="literal-block-wrapper docutils container" id="helloframebuffering-waitforgpu-code">
<div class="code-block-caption"><span class="caption-text">D3D12HelloFrameBuffering/D3D12HelloFrameBuffering.cpp</span><a class="headerlink" href="#helloframebuffering-waitforgpu-code" title="Link to this code">#</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Wait for pending GPU work to complete.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">D3D12HelloFrameBuffering::WaitForGpu</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Schedule a Signal command in the queue.</span>
<span class="w">    </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">m_commandQueue</span><span class="o">-&gt;</span><span class="n">Signal</span><span class="p">(</span><span class="n">m_fence</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span><span class="w"> </span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">]));</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Wait until the fence has been processed.</span>
<span class="w">    </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">m_fence</span><span class="o">-&gt;</span><span class="n">SetEventOnCompletion</span><span class="p">(</span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">],</span><span class="w"> </span><span class="n">m_fenceEvent</span><span class="p">));</span>
<span class="w">    </span><span class="n">WaitForSingleObjectEx</span><span class="p">(</span><span class="n">m_fenceEvent</span><span class="p">,</span><span class="w"> </span><span class="n">INFINITE</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">);</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Increment the fence value for the current frame.</span>
<span class="w">    </span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>The implementation of the <strong>WaitForGPU</strong> function is similar to that of the old <strong>WaitForPreviousFrame</strong> function used in previous samples, as its purpose is to flush the command queue. First, we insert into the command queue a fence with a value associated with the command list of the “current frame” (or rather, rendering work, as we will use this function to flush the command queue after the initialization phase). Then, we wait for the GPU to meet and signal this fence. At that point, we are sure there are no commands left to execute in the command queue. Finally, we increment the fence value to delimit the command list of the next frame. <br>
Observe that we “wasted” the fence value 1 to flush the command queue after the initialization phase. Therefore, we need a new fence value to delimit the first frame. Currently, the first element of the array <strong>m_fenceValues</strong> has a value of 2, which will be used to delimit the command list of the first frame, while the second element of <strong>m_fenceValues</strong> is still 0, and will be used to track the command list of the second frame.</p>
<p>In <strong>OnRender</strong>, we now use the <strong>MoveToNextFrame</strong> function instead of the older <strong>WaitForPreviousFrame</strong> to synchronize the presentation of the frames created in advance on the CPU timeline.</p>
<div class="literal-block-wrapper docutils container" id="helloframebuffering-onrender-code">
<div class="code-block-caption"><span class="caption-text">D3D12HelloFrameBuffering/D3D12HelloFrameBuffering.cpp</span><a class="headerlink" href="#helloframebuffering-onrender-code" title="Link to this code">#</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Render the scene.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">D3D12HelloFrameBuffering::OnRender</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Record all the commands we need to render the scene into the command list.</span>
<span class="w">    </span><span class="n">PopulateCommandList</span><span class="p">();</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Execute the command list.</span>
<span class="w">    </span><span class="n">ID3D12CommandList</span><span class="o">*</span><span class="w"> </span><span class="n">ppCommandLists</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">m_commandList</span><span class="p">.</span><span class="n">Get</span><span class="p">()</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">m_commandQueue</span><span class="o">-&gt;</span><span class="n">ExecuteCommandLists</span><span class="p">(</span><span class="n">_countof</span><span class="p">(</span><span class="n">ppCommandLists</span><span class="p">),</span><span class="w"> </span><span class="n">ppCommandLists</span><span class="p">);</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Present the frame.</span>
<span class="w">    </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">m_swapChain</span><span class="o">-&gt;</span><span class="n">Present</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w"> </span>
<span class="w">    </span><span class="n">MoveToNextFrame</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="helloframebuffering-movetonextframe-code">
<div class="code-block-caption"><span class="caption-text">D3D12HelloFrameBuffering/D3D12HelloFrameBuffering.cpp</span><a class="headerlink" href="#helloframebuffering-movetonextframe-code" title="Link to this code">#</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Prepare to render the next frame.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">D3D12HelloFrameBuffering::MoveToNextFrame</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Schedule a Signal command in the queue.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UINT64</span><span class="w"> </span><span class="n">currentFenceValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">];</span>
<span class="w">    </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">m_commandQueue</span><span class="o">-&gt;</span><span class="n">Signal</span><span class="p">(</span><span class="n">m_fence</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span><span class="w"> </span><span class="n">currentFenceValue</span><span class="p">));</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Update the frame index.</span>
<span class="w">    </span><span class="n">m_frameIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_swapChain</span><span class="o">-&gt;</span><span class="n">GetCurrentBackBufferIndex</span><span class="p">();</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// If the next frame is not ready to be rendered yet, wait until it is ready.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_fence</span><span class="o">-&gt;</span><span class="n">GetCompletedValue</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">])</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">m_fence</span><span class="o">-&gt;</span><span class="n">SetEventOnCompletion</span><span class="p">(</span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">],</span><span class="w"> </span><span class="n">m_fenceEvent</span><span class="p">));</span>
<span class="w">        </span><span class="n">WaitForSingleObjectEx</span><span class="p">(</span><span class="n">m_fenceEvent</span><span class="p">,</span><span class="w"> </span><span class="n">INFINITE</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w"> </span>
<span class="w">    </span><span class="c1">// Set the fence value for the next frame.</span>
<span class="w">    </span><span class="n">m_fenceValues</span><span class="p">[</span><span class="n">m_frameIndex</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentFenceValue</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>In <strong>MoveToNextFrame</strong>, we first initialize the <strong>currentFenceValue</strong> local variable with the fence value that will delimit the command list of the current frame. Subsequently, we place a fence with that value in the command queue since the command list of the current frame has already been submitted in <strong>OnRender</strong>. <br>
<strong>GetCurrentBackBufferIndex</strong> returns the index of the back buffer where we will draw the next frame (updated in <strong>OnRender</strong> by the call to <strong>Present</strong>). However, since we are still processing the current frame, we can use this index to get the fence value of the previous frame as well. At this point, using <strong>m_fenceValues[m_frameIndex]</strong>, we obtain the fence value of the frame before the current one, given that we only alternate between two frames/buffers: the current and the previous ones (the next frame will overwrite the previous one, but at that point, we consider it the current frame). <br>
The <strong>if</strong> block is not entered if the value of the last fence the GPU encountered in the command queue is greater than or equal to the fence value of the previous frame. Indeed, only in that case can we be sure that the GPU has finished drawing the previous frame, allowing us to reuse the related command list and allocator to create the next frame. <br>
Finally, we set the fence value of the next frame to the incremented fence value of the current frame, ensuring a clear distinction between the two frames we can queue to the GPU. <br>
Whenever <strong>MoveToNextFrame</strong> returns, we are ready to create another frame on the CPU timeline.</p>
<p>Above I just explained the theory behind <strong>MoveToNextFrame</strong>. Now, it can be useful to see what happens in practice. <br>
On the first call to <strong>MoveToNextFrame</strong>, <strong>currentFenceValue</strong> is 2 (to delimit the first frame), while <strong>m_fenceValues[m_frameIndex]</strong> is 0 after the call to <strong>GetCurrentBackBufferIndex</strong> since this is still the fence value of the “previous” frame ─ obviously, there are no frames before the first one, but we haven’t drawn the second frame yet, so we can use its fence value to reference a dummy previous frame. <strong>GetCompletedValue</strong> returns at least 1, as it was the value of the fence the GPU had already encountered when we flushed the command queue by calling <strong>WaitForGPU</strong> in <a class="reference internal" href="#helloframebuffering-loadassets-code"><span class="std std-ref"><strong>LoadAssets</strong></span></a>. Therefore, we won’t enter the <strong>if</strong> block. At the end, we set the fence value of the next frame to the incremented fence value of the current frame (i.e., we set 3 to <strong>m_fenceValues[m_frameIndex]</strong> because the fence value of the current frame is 2). <br>
On the next call to <strong>MoveToNextFrame</strong>, <strong>currentFenceValue</strong> will be 3, while the fence value of the previous frame will be 2. So, we won’t enter the if block unless <strong>GetCompletedValue</strong> returns a value less than 2, indicating that the GPU has not finished drawing the previous frame yet. And so on.</p>
<br>
</section>
<section id="source-code">
<h2>Source Code<a class="headerlink" href="#source-code" title="Link to this heading">#</a></h2>
<p><a class="reference external" href="https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/Samples/Desktop/D3D12HelloWorld">D3D12HelloWorld (DirectX-Graphics-Samples)</a></p>
<br>
<div class="admonition-support-this-project admonition">
<p class="admonition-title">Support this project</p>
<p>If you found the content of this tutorial somewhat useful or interesting, please consider supporting this project by clicking on the Sponsor button below. Whether a small tip, a one-time donation, or a recurring payment, all contributions are welcome! Thank you!</p>
<figure class="align-center">
<a class="reference external image-reference" href="https://github.com/sponsors/PAMinerva"><img alt="../../_images/sponsor.png" src="../../_images/sponsor.png" /></a>
</figure>
</div>
<br>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Tutorials\01-HelloDirectX"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="hello-texture.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Hello Texture</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cpu-gpu-parallelism">CPU-GPU parallelism</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#d3d12helloframebuffering-code-review">D3D12HelloFrameBuffering: code review</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">Source Code</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By P. A. Minerva
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>